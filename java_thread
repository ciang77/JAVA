1.并行跟并发有什么区别？
并行是多核 CPU 上的多任务处理，多个任务在同一时间真正地同时执行。
并发是单核 CPU 上的多任务处理，多个任务在同一时间段内交替执行，通过时间片轮转实现交替执行，用于解决 IO 密集型任务的瓶颈。

你是如何理解线程安全的？
如果一段代码块或者一个方法被多个线程同时执行，还能够正确地处理共享数据，那么这段代码块或者这个方法就是线程安全的。

可以从三个要素来确保线程安全：
①、原子性：一个操作要么完全执行，要么完全不执行，不会出现中间状态。可以通过同步关键字 synchronized 或原子操作，如 AtomicInteger 来保证原子性。
②、可见性：当一个线程修改了共享变量，其他线程能够立即看到变化。
③、有序性：要确保线程不会因为死锁、饥饿、活锁等问题导致无法继续执行。

2.说说进程和线程的区别？
进程说简单点就是我们在电脑上启动的一个个应用。它是操作系统分配资源的最小单位。
线程是进程中的独立执行单元。多个线程可以共享同一个进程的资源，如内存；每个线程都有自己独立的栈和寄存器。

如何理解协程？
协程被视为比线程更轻量级的并发单元，可以在单线程中实现并发执行，由我们开发者显式调度。
协程是在用户态进行调度的，避免了线程切换时的内核态开销。
Java 自身是不支持携程的，我们可以使用 Quasar、Kotlin 等框架来实现协程

线程间是如何进行通信的？
原则上可以通过消息传递和共享内存两种方法来实现。Java 采用的是共享内存的并发模型。
这个模型被称为 Java 内存模型，简写为 JMM，它决定了一个线程对共享变量的写入，何时对另外一个线程可见。当然了，本地内存是 JMM 的一个抽象概念，并不真实存在。
用一句话来概括就是：共享变量存储在主内存中，每个线程的私有本地内存，存储的是这个共享变量的副本。

3.说说线程有几种创建方式？
有三种，分别是继承 Thread 类、实现 Runnable 接口、实现 Callable 接口。、

①、第一种需要重写父类 Thread 的 run() 方法，并且调用 start() 方法启动线程。这种方法的缺点是，如果 ThreadTask 已经继承了另外一个类，就不能再继承 Thread 类了，因为 Java 不支持多重继承。
②、第二种需要重写 Runnable 接口的 run() 方法，并将实现类的对象作为参数传递给 Thread 对象的构造方法，最后调用 start() 方法启动线程。这种方法的优点是可以避免 Java 的单继承限制，
并且更符合面向对象的编程思想，因为 Runnable 接口将任务代码和线程控制的代码解耦了。
③、第三种需要重写 Callable 接口的 call() 方法，然后创建 FutureTask 对象，参数为 Callable 实现类的对象；紧接着创建 Thread 对象，参数为 FutureTask 对象，最后调用 start() 方法启动线程。
这种方法的优点是可以获取线程的执行结果。

通过继承Thread类、实现Runnable接口、实现Callable接口都可以实现多线程，不过实现Runnable接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法有返回值，可以声明抛出异常而已。
因此可以将实现Runnable接口和实现Callable接口归为一种方式。

启动一个 Java 程序，你能说说里面有哪些线程吗？
首先是 main 线程，这是程序执行的入口。
然后是垃圾回收线程，它是一个后台线程，负责回收不再使用的对象。
还有编译器线程，比如 JIT，负责把一部分热点代码编译后放到 codeCache 中。

4、调用 start 方法时会执行 run 方法，那怎么不直接调用 run方法？
调用 start() 会创建一个新的线程，并异步执行 run() 方法中的代码。
直接调用 run() 方法只是一个普通的同步方法调用，所有代码都在当前线程中执行，不会创建新线程。没有新的线程创建，也就达不到多线程并发的目的。
也就是说，调用 start() 方法会通知 JVM，去调用底层的线程调度机制来启动新线程。
调用 start() 后，线程进入就绪状态，等待操作系统调度；一旦调度执行，线程会执行其 run() 方法中的代码。

run()和start()有什么区别？
run()方法被称为线程执行体，它的方法体代表了线程需要完成的任务，而start()方法用来启动线程。

调用start()方法启动线程时，系统会把该run()方法当成线程执行体来处理。
但如果直接调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，如果直接调用线程对象的run()方法，系统把线程对象当成一个普通对象，
而run()方法也是一个普通方法，而不是线程执行体。



5、线程有哪些常用的调度方法？
比如说 start 方法用于启动线程并让操作系统调度执行；sleep 方法用于让当前线程休眠一段时间；wait 方法会让当前线程等待，notify 会唤醒一个等待的线程。

说说wait方法和notify方法？
当线程 A 调用共享对象的 wait() 方法时，线程 A 会被阻塞挂起，直到：
线程 B 调用了共享对象的 notify() 方法或者 notifyAll() 方法；
其他线程调用线程 A 的 interrupt() 方法，导致线程 A 抛出 InterruptedException 异常。
线程 A 调用共享对象的 wait(timeout)方法后，没有在指定的 timeout 时间内被其它线程唤醒，那么这个方法会因为超时而返回。
当线程 A 调用共享对象的 notify() 方法后，会唤醒一个在这个共享对象上调用 wait 系列方法被挂起的线程。
共享对象上可能会有多个线程在等待，具体唤醒哪个线程是随机的。
如果调用的是 notifyAll 方法，会唤醒所有在这个共享变量上调用 wait 系列方法而被挂起的线程。

说说 sleep 方法？
当线程 A 调用了 Thread 的 sleep 方法后，线程 A 会暂时让出指定时间的执行权。
指定的睡眠时间到了后该方法会正常返回，接着参与 CPU 调度，获取到 CPU 资源后可以继续执行。

说说yield方法？
yield() 方法的目的是让当前线程让出 CPU 使用权，回到就绪状态。但是线程调度器可能会忽略。

说说interrupt方法？
interrupt() 方法用于通知线程停止，但不会直接终止线程，需要线程自行处理中断标志。
常与 isInterrupted() 或 Thread.interrupted() 配合使用。

6、线程有几种状态？
6 种。
new 代表线程被创建但未启动；runnable 代表线程处于就绪或正在运行状态，由操作系统调度；blocked 代表线程被阻塞，等待获取锁；waiting 代表线程等待其他线程的通知或中断；
timed_waiting 代表线程会等待一段时间，超时后自动恢复；terminated 代表线程执行完毕，生命周期结束。

如何强制终止线程？
第一步，调用线程的 interrupt() 方法，请求终止线程。
第二步，在线程的 run() 方法中检查中断状态，如果线程被中断，就退出线程。

线程是否可以重复启动，会有什么后果？
只能对处于新建状态的线程调用start()方法，否则将引发IllegalThreadStateException异常。

7、什么是线程上下文切换？
线程上下文切换是指 CPU 从一个线程切换到另一个线程执行时的过程。
在线程切换的过程中，CPU 需要保存当前线程的执行状态，并加载下一个线程的上下文。
之所以要这样，是因为 CPU 在同一时刻只能执行一个线程，为了实现多线程并发执行，需要不断地在多个线程之间切换。

线程可以被多核调度吗？
多核处理器提供了并行执行多个线程的能力。每个核心可以独立执行一个或多个线程，操作系统的任务调度器会根据策略和算法，如优先级调度、轮转调度等，决定哪个线程何时在哪个核心上运行。

如何实现线程同步？
同步方法
即有synchronized关键字修饰的方法，由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。需要注意， synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类。

同步代码块
即有synchronized关键字修饰的语句块，被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。需值得注意的是，同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。

ReentrantLock
Java 5新增了一个java.util.concurrent包来支持同步，其中ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。需要注意的是，ReentrantLock还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，因此不推荐使用。

volatile
volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。

原子变量
在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。


8、守护线程了解吗？
了解，守护线程是一种特殊的线程，它的作用是为其他线程提供服务。
Java 中的线程分为两类，一种是守护线程，另外一种是用户线程。
JVM 启动时会调用 main 方法，main 方法所在的线程就是一个用户线程。在 JVM 内部，同时还启动了很多守护线程，比如垃圾回收线程。

守护线程和用户线程有什么区别呢？
区别之一是当最后一个非守护线程束时， JVM 会正常退出，不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM 退出。
换而言之，只要有一个用户线程还没结束，正常情况下 JVM 就不会退出

9、线程间有哪些通信方式？
线程之间传递信息的方式有多种，比如说使用 volatile 和 synchronized 关键字共享对象、使用 wait() 和 notify() 方法实现生产者-消费者模式、使用 Exchanger 进行数据交换、使用 Condition 实现线程间的协调等。

简单说说 volatile 和 synchronized 的使用方式？
多个线程可以通过 volatile 和 synchronized 关键字访问和修改同一个对象，从而实现信息的传递。
关键字 volatile 可以用来修饰成员变量，告知程序任何对该变量的访问均需要从共享内存中获取，并同步刷新回共享内存，保证所有线程对变量访问的可见性。
关键字 synchronized 可以修饰方法，或者同步代码块，确保多个线程在同一个时刻只有一个线程在执行方法或代码块。


volatile关键字有什么用？

当一个变量被定义成volatile之后，它将具备两项特性：
保证可见性
当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，这个写会操作会导致其他线程中的volatile变量缓存无效。

禁止指令重排
使用volatile关键字修饰共享变量可以禁止指令重排序，volatile禁止指令重排序有一些规则：
当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没有进行；
在进行指令优化时，不能将对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。
即执行到volatile变量时，其前面的所有语句都执行完，后面所有语句都未执行。且前面语句的结果对volatile变量及其后面语句可见。
注意，虽然volatile能够保证可见性，但它不能保证原子性。volatile变量在各个线程的工作内存中是不存在一致性问题的，但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。


谈谈volatile的实现原理
volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，
会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，内存屏障会提供3个功能：
它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
它会强制将对缓存的修改操作立即写入主存；
如果是写操作，它会导致其他CPU中对应的缓存行无效。


wait() 和 notify() 方法的使用方式了解吗？
一个线程调用共享对象的 wait() 方法时，它会进入该对象的等待池，释放已经持有的锁，进入等待状态。
一个线程调用 notify() 方法时，它会唤醒在该对象等待池中等待的一个线程，使其进入锁池，等待获取锁。

Exchanger 的使用方式了解吗？
Exchanger 是一个同步点，可以在两个线程之间交换数据。一个线程调用 exchange() 方法，将数据传递给另一个线程，同时接收另一个线程的数据。

如果线程之间采用synchronized来保证线程安全，则可以利用wait()、notify()、notifyAll()来实现线程通信。这三个方法都不是Thread类中所声明的方法，而是Object类中声明的方法。
原因是每个对象都拥有锁，所以让当前线程等待某个对象的锁，当然应该通过这个对象来操作。并且因为当前线程可能会等待多个线程的锁，如果通过线程来操作，就非常复杂了。另外，这三个
方法都是本地方法，并且被final修饰，无法被重写。

如果线程之间采用Lock来保证线程安全，则可以利用await()、signal()、signalAll()来实现线程通信。这三个方法都是Condition接口中的方法，该接口是在Java 1.5中出现的，它用来替代传统的wait+notify实现线程间的协作，
它的使用依赖于 Lock。相比使用wait+notify，使用Condition的await+signal这种方式能够更加安全和高效地实现线程间协作。

10、请说说 sleep 和 wait 的区别？
sleep 会让当前线程休眠，不需要获取对象锁，属于 Thread 类的方法；wait 会让获得对象锁的线程等待，要提前获得对象锁，属于 Object 类的方法。
①、所属类不同 	 	
②、锁行为不同
③、使用条件不同：sleep() 方法可以在任何地方被调用。wait() 方法必须在同步代码块或同步方法中被调用，这是因为调用 wait() 方法的前提是当前线程必须持有对象的锁。否则会抛出 IllegalMonitorStateException 异常。
④、唤醒方式不同：调用 sleep 方法后，线程会进入 TIMED_WAITING 状态，即在指定的时间内暂停执行。当指定的时间结束后，线程会自动恢复到 RUNNABLE 状态，等待 CPU 调度再次执行。调用 wait 方法后，线程会进入 WAITING 状态，直到有其他线程在同一对象上调用 notify 或 notifyAll 方法，线程才会从 WAITING 状态转变为 RUNNABLE 状态，准备再次获得 CPU 的执行权。


说一说notify()、notifyAll()的区别
notify()
用于唤醒一个正在等待相应对象锁的线程，使其进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。

notifyAll()
用于唤醒所有正在等待相应对象锁的线程，使它们进入就绪队列，以便在当前线程释放锁后竞争锁，进而得到CPU的执行。


阻塞线程的方式有哪些？
当发生如下情况时，线程将会进入阻塞状态：

线程调用sleep()方法主动放弃所占用的处理器资源；
线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞；
线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有；
线程在等待某个通知（notify）；
程序调用了线程的suspend()方法将该线程挂起，但这个方法容易导致死锁，所以应该尽量避免使用该方法。


11、怎么保证线程安全？
线程安全是指在并发环境下，多个线程访问共享资源时，程序能够正确地执行，而不会出现数据不一致的问题。
为了保证线程安全，可以使用 synchronized 关键字对方法加锁，对代码块加锁。线程在执行同步方法、同步代码块时，会获取类锁或者对象锁，其他线程就会阻塞并等待锁。
如果需要更细粒度的锁，可以使用 ReentrantLock 并发重入锁等。
如果需要保证变量的内存可见性，可以使用 volatile 关键字。
对于简单的原子变量操作，还可以使用 Atomic 原子类。
对于线程独立的数据，可以使用 ThreadLocal 来为每个线程提供专属的变量副本。
对于需要并发容器的地方，可以使用 ConcurrentHashMap、CopyOnWriteArrayList 等

能说一下 Hashtable 的底层数据结构吗？
与 HashMap 类似，Hashtable 的底层数据结构也是一个数组加上链表的方式，然后通过 synchronized 加锁来保证线程安全。

12、ThreadLocal 是什么？
ThreadLocal 是一种用于实现线程局部变量的工具类。它允许每个线程都拥有自己的独立副本，从而实现线程隔离。
①、创建 ThreadLocal
②、设置 ThreadLocal 的值
③、获取 ThreadLocal 的值
④、删除 ThreadLocal 的值

ThreadLocal 有哪些优点？
每个线程访问的变量副本都是独立的，避免了共享变量引起的线程安全问题。由于 ThreadLocal 实现了变量的线程独占，使得变量不需要同步处理，因此能够避免资源竞争。

你在工作中用到过 ThreadLocal 吗？
有用到过，用来存储用户信息。
智能实验室管理系统在登录后的用户每次访问接口，都会在请求头中携带一个 token，在控制层可以根据这个 token，解析出用户的基本信息。
假如在服务层和持久层也要用到用户信息，就可以在控制层拦截请求把用户信息存入 ThreadLocal。
这样我们在任何一个地方，都可以取出 ThreadLocal 中存的用户信息。
很多其它场景的 cookie、session 等等数据隔离都可以通过 ThreadLocal 去实现。

ThreadLocal 怎么实现的呢？
ThreadLocal 的实现原理是，每个线程维护一个 Map，key 为 ThreadLocal 对象，value 为想要实现线程隔离的对象。
1、通过 ThreadLocal 的 set 方法将对象存入 Map 中。
2、通过 ThreadLocal 的 get 方法从 Map 中取出对象。
3、Map 的大小由 ThreadLocal 对象的多少决定。

ThreadLocal 的设计是每个线程维护一个自己的 ThreadLocalMap，存储变量。
ThreadLocalMap 中的键是 ThreadLocal 对象的 弱引用，值是具体的变量对象。
一旦外部没有强引用指向某个 ThreadLocal 实例，它就可能被 GC 回收。
但 ThreadLocalMap 里的 Entry.value（局部变量）仍然有强引用，导致可能出现 value 内存泄露 的问题。

ThreadLocal 内存泄露是怎么回事？
ThreadLocalMap 的 Key 是 弱引用，但 Value 是强引用。
如果一个线程一直在运行，并且 value 一直指向某个强引用对象，那么这个对象就不会被回收，从而导致内存泄漏。

那怎么解决内存泄漏问题呢？
很简单，使用完 ThreadLocal 后，及时调用 remove() 方法释放内存空间。
remove() 会调用 ThreadLocalMap 的 remove 方法遍历哈希表，找到 key 等于当前 ThreadLocal 的 Entry，找到后会调用 Entry 的 clear 方法，将 Entry 的 value 设置为 null。

那为什么 key 要设计成弱引用？
弱引用的好处是，当内存不足的时候，JVM 能够及时回收掉弱引用的对象。

13、ThreadLocalMap 怎么解决 Hash 冲突的？
开放定址法。
如果计算得到的槽位 i 已经被占用，ThreadLocalMap 会采用开放地址法中的线性探测来寻找下一个空闲槽位：
如果 i 位置被占用，尝试 i+1。
如果 i+1 也被占用，继续探测 i+2，直到找到一个空位。
如果到达数组末尾，则回到数组头部，继续寻找空位。

为什么要用线性探测法而不是HashMap 的拉链法来解决哈希冲突？
ThreadLocalMap 设计的目的是存储线程私有数据，不会有大量的 Key，所以采用线性探测更节省空间。
拉链法还需要单独维护一个链表，甚至红黑树，不适合 ThreadLocal 这种场景。

开放地址法了解吗？
简单来说，就是这个坑被人占了，那就接着去找空着的坑。

13、ThreadLocalMap 扩容机制了解吗？
与 HashMap 不同，ThreadLocalMap 并不会直接在元素数量达到阈值时立即扩容，而是先清理被 GC 回收的 key，然后在填充率达到四分之三时进行扩容。
清理过程会遍历整个数组，将 key 为 null 的 Entry 清除。
阈值 threshold 的默认值是数组长度的三分之二。
扩容时，会将数组长度翻倍，然后重新计算每个 Entry 的位置，采用线性探测法来寻找新的空位，然后将 Entry 放入新的数组中。

一句话总结：ThreadLocalMap 采用的是“先清理再扩容”的策略，扩容时，数组长度翻倍，并重新计算索引，如果发生哈希冲突，采用线性探测法来解决。 

14、父线程能用 ThreadLocal 给子线程传值吗？
不能。
因为 ThreadLocal 变量存储在每个线程的 ThreadLocalMap 中，而子线程不会继承父线程的 ThreadLocalMap。
可以使用 InheritableThreadLocal来解决这个问题。
子线程在创建的时候会拷贝父线程的 InheritableThreadLocal 变量。

15、说说 Java 的内存模型
Java 内存模型是 Java 虚拟机规范中定义的一个抽象模型，用来描述多线程环境中共享变量的内存可见性。
共享变量存储在主内存中，每个线程都有一个私有的本地内存，存储了共享变量的副本。
当一个线程更改了本地内存中共享变量的副本，它需要 JVM 刷新到主内存中，以确保其他线程可以看到这些更改。
当一个线程需要读取共享变量时，它一版会从本地内存中读取。如果本地内存中的副本是过时的，JVM 会将主内存中的共享变量最新值刷新到本地内存中。

为什么线程要用自己的内存？
线程从主内存拷贝变量到工作内存，可以减少 CPU 访问 RAM 的开销。
每个线程都有自己的变量副本，可以避免多个线程同时修改共享变量导致的数据冲突。

16、 i++是原子操作吗？
不是，它包括三个步骤：
从内存中读取 i 的值。
对 i 进行加 1 操作。
将新的值写回内存。
说说你对原子性、可见性、有序性的理解？

原子性要求一个操作是不可分割的，要么全部执行成功，要么完全不执行。
举个例子：就比如说 count++ 就不是一个原子操作，它包括读取 count 的值、加 1、写回 count 三个步骤，所以需要加锁或者使用AtomicInteger代替 int 来保证原子性。

可见性要求一个线程对共享变量的修改，能够被其他线程及时看见。

有序性是指程序执行的顺序是否按照代码编写的顺序执行。在单线程环境下，代码能够准确无误地按照编写顺序执行。但在多线程环境下，CPU 和编译器可能会进行指令重排，代码的执行顺序因此会发生变化。

17、说说什么是指令重排？
指令重排是指 CPU 或编译器为了提高程序的执行效率，改变代码执行顺序的一种优化技术。
从 Java 源代码到最终执行的指令序列，会经历 3 种重排序：编译器重排序、指令并行重排序、内存系统重排序。

18、volatile 了解吗？
第一，保证可见性，线程修改 volatile 变量后，其他线程能够立即看到最新值；第二，防止指令重排，volatile 变量的写入不会被重排序到它之前的代码。
volatile 怎么保证可见性的？
当线程对 volatile 变量进行写操作时，JVM 会在这个变量写入之后插入一个写屏障指令，这个指令会强制将本地内存中的变量值刷新到主内存中
当线程对 volatile 变量进行读操作时，JVM 会插入一个读屏障指令，这个指令会强制让本地内存中的变量值失效，从而重新从主内存中读取最新的值。

volatile 和 synchronized 的区别？
volatile 关键字用于修饰变量，确保该变量的更新操作对所有线程是可见的，即一旦某个线程修改了 volatile 变量，其他线程会立即看到最新的值。
synchronized 关键字用于修饰方法或代码块，确保同一时刻只有一个线程能够执行该方法或代码块，从而实现互斥访问。

说一说synchronized与Lock的区别
synchronized是Java关键字，在JVM层面实现加锁和解锁；Lock是一个接口，在代码层面实现加锁和解锁。
synchronized可以用在代码块上、方法上；Lock只能写在代码里。
synchronized在代码执行完或出现异常时自动释放锁；Lock不会自动释放锁，需要在finally中显示释放锁。
synchronized会导致线程拿不到锁一直等待；Lock可以设置获取锁失败的超时时间。
synchronized无法得知是否获取锁成功；Lock则可以通过tryLock得知加锁是否成功。
synchronized锁可重入、不可中断、非公平；Lock锁可重入、可中断、可公平/不公平，并可以细分读写锁以提高效率。


17、synchronized 用过吗？
synchronized 上锁的对象是什么？
synchronized 用在普通方法上时，上锁的是执行这个方法的对象。
synchronized 用在静态方法上时，上锁的是这个类的 Class 对象。
synchronized 用在代码块上时，上锁的是括号中指定的对象，比如说当前对象 this。

18、synchronized 的实现原理了解吗？
synchronized 依赖 JVM 内部的 Monitor 对象来实现线程同步。使用的时候不用手动去 lock 和 unlock，JVM 会自动加锁和解锁。
synchronized 加锁代码块时，JVM 会通过 monitorenter、monitorexit 两个指令来实现同步：
前者表示线程正在尝试获取 lock 对象的 Monitor；
后者表示线程执行完了同步代码块，正在释放锁。

synchronized 怎么保证可见性？
通过两步操作：
加锁时，线程必须从主内存读取最新数据。
释放锁时，线程必须将修改的数据刷回主内存，这样其他线程获取锁后，就能看到最新的数据。

synchronized 怎么保证有序性？
synchronized 通过 JVM 指令 monitorenter 和 monitorexit，来确保加锁代码块内的指令不会被重排。

synchronized 锁升级了解吗？
JDK 1.6 的时候，为了提升 synchronized 的性能，引入了锁升级机制，从低开销的锁逐步升级到高开销的锁，以最大程度减少锁的竞争。
没有线程竞争时，就使用低开销的“偏向锁”，此时没有额外的 CAS 操作；轻度竞争时，使用“轻量级锁”，采用 CAS 自旋，避免线程阻塞；只有在重度竞争时，才使用“重量级锁”，由 Monitor 机制实现，需要线程阻塞。

说说自旋锁？
自旋锁是指当线程尝试获取锁时，如果锁已经被占用，线程不会立即阻塞，而是通过自旋，也就是循环等待的方式不断尝试获取锁。

了解 synchronized 四种锁状态吗？
①、无锁状态，对象未被锁定，Mark Word 存储对象的哈希码等信息。
②、偏向锁，当线程第一次获取锁时，会进入偏向模式。Mark Word 会记录线程 ID，后续同一线程再次获取锁时，可以直接进入 synchronized 加锁的代码，无需额外加锁。
③、轻量级锁，当多个线程在不同时段获取同一把锁，即不存在锁竞争的情况时，JVM 会采用轻量级锁来避免线程阻塞。未持有锁的线程通过CAS 自旋等待锁释放。
④、重量级锁，如果自旋超过一定的次数，或者一个线程持有锁，一个自旋，又有第三个线程进入 synchronized 加锁的代码时，轻量级锁就会升级为重量级锁。

synchronized可以修饰静态方法和静态代码块吗？
synchronized可以修饰静态方法，但不能修饰静态代码块。
当修饰静态方法时，监视器锁（monitor）便是对象的Class实例，因为Class数据存在于永久代，因此静态方法锁相当于该类的一个全局锁。

19、synchronized 和 ReentrantLock 的区别了解吗？
两句话回答：synchronized 由 JVM 内部的 Monitor 机制实现，ReentrantLock基于 AQS 实现。
synchronized 可以自动加锁和解锁，ReentrantLock 需要手动 lock() 和 unlock()。

并发量大的情况下，使用 synchronized 还是 ReentrantLock？
我更倾向于 ReentrantLock，因为：
ReentrantLock 提供了超时和公平锁等特性，可以应对更复杂的并发场景。
ReentrantLock 允许更细粒度的锁控制，能有效减少锁竞争。
ReentrantLock 支持条件变量 Condition，可以实现比 synchronized 更友好的线程间通信机制。

谈谈ReentrantLock的实现原理

ReentrantLock是基于AQS实现的，AQS即AbstractQueuedSynchronizer的缩写，这个是个内部实现了两个队列的抽象类，分别是同步队列和条件队列。其中同步队列是一个双向链表，
里面储存的是处于等待状态的线程，正在排队等待唤醒去获取锁，而条件队列是一个单向链表，里面储存的也是处于等待状态的线程，只不过这些线程唤醒的结果是加入到了同步队列的队尾，
AQS所做的就是管理这两个队列里面线程之间的等待状态-唤醒的工作。

在同步队列中，还存在2中模式，分别是独占模式和共享模式，这两种模式的区别就在于AQS在唤醒线程节点的时候是不是传递唤醒，这两种模式分别对应独占锁和共享锁。
AQS是一个抽象类，所以不能直接实例化，当我们需要实现一个自定义锁的时候可以去继承AQS然后重写获取锁的方式和释放锁的方式还有管理state，而ReentrantLock就是通过重写
了AQS的tryAcquire和tryRelease方法实现的lock和unlock。

20、线程死锁了解吗？
死锁发生在多个线程相互等待对方释放锁时。比如说线程 1 持有锁 R1，等待锁 R2；线程 2 持有锁 R2，等待锁 R1。

死锁发生的四个条件了解吗？
第一条件是互斥：资源不能被多个线程共享，一次只能由一个线程使用。如果一个线程已经占用了一个资源，其他请求该资源的线程必须等待，直到资源被释放。
第二个条件是持有并等待：一个线程已经持有一个资源，并且在等待获取其他线程持有的资源。
第三个条件是不可抢占：资源不能被强制从线程中夺走，必须等线程自己释放。
第四个条件是循环等待：存在一种线程等待链，线程 A 等待线程 B 持有的资源，线程 B 等待线程 C 持有的资源，直到线程 N 又等待线程 A 持有的资源

该如何避免死锁呢？
第一，所有线程都按照固定的顺序来申请资源。例如，先申请 R1 再申请 R2。
第二，如果线程发现无法获取某个资源，可以先释放已经持有的资源，重新尝试申请。

21、死锁问题怎么排查呢？
首先从系统级别上排查，比如说在 Linux 生产环境中，可以先使用 top ps 等命令查看进程状态，看看是否有进程占用了过多的资源。
接着，使用 JDK 自带的一些性能监控工具进行排查，比如说 使用 jps -l 查看当前进程，然后使用 jstack 进程号 查看当前进程的线程堆栈信息，看看是否有线程在等待锁资源。
也可以使用一些可视化的性能监控工具，比如说 JConsole、VisualVM 等，查看线程的运行状态、锁的竞争情况等。

22、聊聊线程同步和互斥？（补充）
同步，意味着线程之间要密切合作，按照一定的顺序来执行任务。比如说，线程 A 先执行，线程 B 再执行。
互斥，意味着线程之间要抢占资源，同一时间只能有一个线程访问共享资源。比如说，线程 A 在访问共享资源时，线程 B 不能访问。
同步关注的是线程之间的协作，互斥关注的是线程之间的竞争。

如何实现同步和互斥？
可以使用 synchronized 关键字或者 Lock 接口的实现类，如 ReentrantLock 来给资源加锁。
锁在操作系统层面的意思是 Mutex，某个线程进入临界区后，也就是获取到锁后，其他线程不能再进入临界区，要阻塞等待持有锁的线程离开临界区。

23、聊聊悲观锁和乐观锁？（补充）
悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java中悲观锁是通过synchronized关键字或Lock接口来实现的。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，这样可以提高吞吐量。
在JDK1.5 中新增 java.util.concurrent (J.U.C)就是建立在CAS之上的。相对于对于 synchronized 这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。

24、什么是线程池？
线程池是用来管理和复用线程的工具，它可以减少线程的创建和销毁开销。
在 Java 中，ThreadPoolExecutor 是线程池的核心实现，它通过核心线程数、最大线程数、任务队列和拒绝策略来控制线程的创建和执行。

说一下线程池的工作流程？
可以简单总结为：
任务提交 → 核心线程执行 → 任务队列缓存 → 非核心线程执行 → 拒绝策略处理。

线程池的主要参数有哪些？
线程池有 7 个参数，需要重点关注的有核心线程数、最大线程数、等待队列、拒绝策略。

线程池的拒绝策略有哪些？
AbortPolicy：默认的拒绝策略，会抛 RejectedExecutionException 异常。
CallerRunsPolicy：让提交任务的线程自己来执行这个任务，也就是调用 execute 方法的线程。
DiscardOldestPolicy：等待队列会丢弃队列中最老的一个任务，也就是队列中等待最久的任务，然后尝试重新提交被拒绝的任务。
DiscardPolicy：丢弃被拒绝的任务，不做任何处理也不抛出异常。
当线程池无法接受新的任务时，也就是线程数达到 maximumPoolSize，任务队列也满了的时候，就会触发拒绝策略。

线程池有哪几种阻塞队列？
常用的有五种，有界队列 ArrayBlockingQueue；无界队列 LinkedBlockingQueue；优先级队列 PriorityBlockingQueue；延迟队列 DelayQueue；同步队列 SynchronousQueue。

25、线程池提交 execute 和 submit 有什么区别？
execute 方法没有返回值，适用于不关心结果和异常的简单任务。
submit 有返回值，适用于需要获取结果或处理异常的场景。

线程池怎么关闭知道吗？
可以调用线程池的shutdown或shutdownNow方法来关闭线程池。

shutdown 不会立即停止线程池，而是等待所有任务执行完毕后再关闭线程池。 
shutdownNow 会尝试通过一系列动作来停止线程池，包括停止接收外部提交的任务、忽略队列里等待的任务、尝试将正在跑的任务 interrupt 中断。
需要注意的是，shutdownNow 不会真正终止正在运行的任务，只是给任务线程发送 interrupt 信号，任务是否能真正终止取决于线程是否响应 InterruptedException。

26、线程池的线程数应该怎么配置？
首先，我会分析线程池中执行的任务类型是 CPU 密集型还是 IO 密集型？
①、对于 CPU 密集型任务，我的目标是尽量减少线程上下文切换，以优化 CPU 使用率。一般来说，核心线程数设置为处理器的核心数或核心数加一是较理想的选择。
②、对于 IO 密集型任务，由于线程经常处于等待状态，等待 IO 操作完成，所以可以设置更多的线程来提高并发，比如说 CPU 核心数的两倍。

27、有哪几种常见的线程池？
主要有四种：

固定大小的线程池 Executors.newFixedThreadPool(int nThreads);，适合用于任务数量确定，且对线程数有明确要求的场景。例如，IO 密集型任务、数据库连接池等。
缓存线程池 Executors.newCachedThreadPool();，适用于短时间内任务量波动较大的场景。例如，短时间内有大量的文件处理任务或网络请求。
定时任务线程池 Executors.newScheduledThreadPool(int corePoolSize);，适用于需要定时执行任务的场景。例如，定时发送邮件、定时备份数据等。
单线程线程池 Executors.newSingleThreadExecutor();，适用于需要按顺序执行任务的场景。例如，日志记录、文件处理等。

线程池异常怎么处理知道吗？
常见的处理方式有，使用 try-catch 捕获、使用 Future 获取异常、自定义ThreadPoolExecutor 重写 afterExecute 方法、使用 UncaughtExceptionHandler 捕获异常。

能说一下线程池有几种状态吗？
有 5 种状态，它们的转换遵循严格的状态流转规则，不同状态控制着线程池的任务调度和关闭行为。
状态由 RUNNING → SHUTDOWN → STOP → TIDYING → TERMINATED 依次流转。
RUNNING 状态的线程池可以接收新任务，并处理阻塞队列中的任务；SHUTDOWN 状态的线程池不会接收新任务，但会处理阻塞队列中的任务；STOP 状态的线程池不会接收新任务，也不会处理阻塞队列中的任务，并且会尝试中断正在执行的任务；TIDYING 状态表示所有任务已经终止；TERMINATED 状态表示线程池完全关闭，所有线程销毁。

线程池如何实现参数的动态修改？
线程池提供的 setter 方法就可以在运行时动态修改参数，比如说 setCorePoolSize 可以用来修改核心线程数、setMaximumPoolSize 可以用来修改最大线程数。 	
当然了，还可以利用 Nacos 配置中心，或者实现自定义的线程池，监听参数变化去动态调整参数。

28、线程池调优了解吗？
首先我会根据任务类型设置核心线程数参数，比如 IO 密集型任务会设置为 CPU 核心数*2 的经验值。
其次我会结合线程池动态调整的能力，在流量波动时通过 setCorePoolSize 平滑扩容，或者直接使用 DynamicTp 实现线程池参数的自动化调整。
最后，我会通过内置的监控指标建立容量预警机制。比如通过 JMX 监控线程池的运行状态，设置阈值，当线程池的任务队列长度超过阈值时，触发告警。

线程池在使用的时候需要注意什么？（补充）
第一个，选择合适的线程池大小。过小的线程池可能会导致任务一直在排队；过大的线程池可能会导致大家都在竞争 CPU 资源，增加上下文切换的开销
第二个，选择合适的任务队列。使用有界队列可以避免资源耗尽的风险，但是可能会导致任务被拒绝；使用无界队列虽然可以避免任务被拒绝，但是可能会导致内存耗尽
比如在使用 LinkedBlockingQueue 的时候，可以传入参数来限制队列中任务的数量，这样就不会出现 OOM。
第三个，尽量使用自定义的线程池，而不是使用 Executors 创建的线程池。
因为 newFixedThreadPool 线程池由于使用了 LinkedBlockingQueue，队列的容量默认无限大，任务过多时会导致内存溢出；newCachedThreadPool 线程池由于核心线程数无限大，当任务过多的时候会导致创建大量的线程，导致服务器负载过高宕机。

29、线程池执行中断电了应该怎么处理？
线程池本身只能在内存中进行任务调度，并不会持久化，一旦断电，线程池里的所有任务和状态都会丢失。
我会考虑以下几个方面：
第一，持久化任务。可以将任务持久化到数据库或者消息队列中，等电恢复后再重新执行。
第二，任务幂等性，需要保证任务是幂等的，也就是无论执行多少次，结果都一致。
第三，恢复策略。当系统重启时，应该有一个恢复流程：检测上次是否有未完成的任务，将这些任务重新加载到线程池中执行，确保断电前的工作能够恢复。

30、如果不使用synchronized和Lock，如何保证线程安全？

volatile
volatile关键字为域变量的访问提供了一种免锁机制，使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，因此每次使用该域就要重新计算，而不是使用寄存器中的值。需要注意的是，volatile不会提供任何原子操作
，它也不能用来修饰final类型的变量。

原子变量
在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。例如AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中（如以原子方式增加的计数器），
但不能用于替换Integer。可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。

本地存储
可以通过ThreadLocal类来实现线程本地存储的功能。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，
ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。

不可变的
只要一个不可变的对象被正确地构建出来，那其外部的可见状态永远都不会改变，永远都不会看到它在多个线程之中处于不一致的状态，“不可变”带来的安全性是最直接、最纯粹的。Java语言中，如果多线程共享的数据
是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任
何影响才行。String类是一个典型的不可变类，可以参考它设计一个不可变类。

31、公平锁与非公平锁是怎么实现的？
参考答案

在Java中实现锁的方式有两种，一种是使用Java自带的关键字synchronized对相应的类或者方法以及代码块进行加锁，
另一种是ReentrantLock，前者只能是非公平锁，而后者是默认非公平但可实现公平的一把锁。

ReentrantLock是基于其内部类FairSync(公平锁)和NonFairSync(非公平锁)实现的，并且它的实现依赖于Java同步器框架AbstractQueuedSynchronizer（AQS），AQS使用一个整形的volatile变量state来维护同步状态，
这个volatile变量是实现ReentrantLock的关键。

32、分段锁是怎么实现的？

在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。

我们一般有三种方式降低锁的竞争程度：
减少锁的持有时间；
降低锁的请求频率；
使用带有协调机制的独占锁，这些机制允许更高的并发性。

在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这称为分段锁。其实说的简单一点就是：容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，
线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，
其他段的数据也能被其他线程访问。

33、说说你对读写锁的了解

与传统锁不同的是读写锁的规则是可以共享读，但只能一个写，总结起来为：读读不互斥、读写互斥、写写互斥，而一般的独占锁是：读读互斥、读写互斥、写写互斥，而场景中往往读远远大于写，
读写锁就是为了这种优化而创建出来的一种机制。 注意是读远远大于写，一般情况下独占锁的效率低来源于高并发下对临界区的激烈竞争导致线程上下文切换。因此当并发不是很高的情况下，
读写锁由于需要额外维护读锁的状态，可能还不如独占锁的效率高。因此需要根据实际情况选择使用。

在Java中ReadWriteLock的主要实现为ReentrantReadWriteLock，其提供了以下特性：

公平性选择：支持公平与非公平（默认）的锁获取方式，吞吐量非公平优先于公平。
可重入：读线程获取读锁之后可以再次获取读锁，写线程获取写锁之后可以再次获取写锁。
可降级：写线程获取写锁之后，其还可以再次获取读锁，然后释放掉写锁，那么此时该线程是读锁状态，也就是降级操作。





