1、什么是Mybatis
Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，
可以严格控制 sql 执行性能，灵活度高。MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。

ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单 Java 对象（POJO）的映射关系的技术。简单来说，ORM 是通过使用描述对象和数据库之间映射的元数据，
将程序中的对象自动持久化到关系型数据库中。

为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？
Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
而 Mybatis 在查询关联对象或关联集合对象时，需要手动编写 SQL 来完成，所以，被称之为半自动 ORM 映射工具。

JDBC有什么不足，mybatis是怎么解决的？
1、数据连接创建、释放频繁造成系统资源浪费从而影响系统性能，在 mybatis-config.xml 中配置数据链接池，使用连接池统一管理数据库连接。
2、sql 语句写在代码中造成代码不易维护，将 sql 语句配置在 XXXXmapper.xml 文件中与 java 代码分离。
3、向 sql 语句传参数麻烦，因为 sql 语句的 where 条件不一定，可能多也可能少，占位符需要和参数一一对应。Mybatis 自动将 java 对象映射至 sql 语句。
4、对结果集解析麻烦，sql 变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成 pojo 对象解析比较方便。Mybatis 自动将 sql 执行结果映射至 java 对象。

2、Hibernate 和 MyBatis 有什么区别？
相同点
都是对 jdbc 的封装，都是应用于持久层的框架。

不同点

1）映射关系
MyBatis 是一个半自动映射的框架，配置 Java 对象与 sql 语句执行结果的对应关系，多表关联关系配置简单
Hibernate 是一个全表映射的框架，配置 Java 对象与数据库表的对应关系，多表关联关系配置复杂

2）SQL 优化和移植性
Hibernate 对 SQL 语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。
如果项目需要支持多种数据库，代码开发量少，但 SQL 语句优化困难。MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。
直接使用 SQL 语句操作数据库，不支持数据库无关性，但 sql 语句优化容易。

3）MyBatis 和 Hibernate 的适用场景不同
Hibernate 是标准的 ORM 框架，SQL 编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统
MyBatis 是半 ORM 框架，需要编写较多 SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站

3、在 mapper 中如何传递多个参数？
方法 1：顺序传参法
方法 2：@Param 注解传参法
方法 3：Map 传参法
方法 4：Java Bean 传参法

4、实体类属性名和表中字段名不一样 ，怎么办?
第 1 种： 通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。
第 2 种： 通过 resultMap 中的<result>来映射字段名和实体类属性名的一一对应的关系。

5、#{}和${}的区别?
#{} 是预编译处理，${} 是字符串替换。

①、当使用 #{} 时，MyBatis 会在 SQL 执行之前，将占位符替换为问号 ?，并使用参数值来替代这些问号。
由于 #{} 使用了预处理，所以能有效防止 SQL 注入，确保参数值在到达数据库之前被正确地处理和转义。

②、当使用 ${} 时，参数的值会直接替换到 SQL 语句中去，而不会经过预处理。
这就存在 SQL 注入的风险，因为参数值会直接拼接到 SQL 语句中，假如参数值是 1 or 1=1，那么 SQL 语句就会变成 SELECT * FROM users WHERE id = 1 or 1=1，这样就会导致查询出所有用户的结果。
${} 通常用于那些不能使用预处理的场合，比如说动态表名、列名、排序等，要提前对参数进行安全性校验。

6、Mybatis 能执行一对一、一对多的关联查询吗？
当然可以，不止支持一对一、一对多的关联查询，还支持多对多、多对一的关联查询。

7、Mybatis 是否支持延迟加载？原理？
Mybatis 支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 Mybatis 配置文件中，可以配置是否启用
延迟加载 lazyLoadingEnabled=true|false。

它的原理是，使用 CGLIB 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 a.getB().getName()，拦截器 invoke()方法发现 a.getB()是 null 值，那么就会单独发送
事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。
当然了，不光是 Mybatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。

8、MyBatis 支持动态 SQL 吗？
MyBatis 中有一些支持动态 SQL 的标签，它们的原理是使用 OGNL 从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL，以此来完成动态 SQL 的功能。
if  choose  trim  set  foreach等等

9、MyBatis 如何执行批量操作？
第一种方法：使用 foreach 标签
第二种方法：使用 ExecutorType.BATCH

10、说说 Mybatis 的一级、二级缓存？
一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 SqlSession，各个 SqlSession 之间的缓存相互隔离，当 Session flush 或 close 之后，
该 SqlSession 中的所有 Cache 就将清空，MyBatis 默认打开一级缓存。

二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同之处在于其存储作用域为 Mapper(Namespace)，可以在多个 SqlSession 之间共享，
并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现 Serializable 序列化接口(可用来保存对象的状态),可在它的映射文件中配置。

11、能说说 MyBatis 的工作原理吗？
我们已经大概知道了 MyBatis 的工作流程，按工作原理，可以分为两大步：生成会话工厂、会话运行。

生成会话工厂分为两步：

获取配置
获取配置这一步经过了几步转化，最终由生成了一个配置类 Configuration 实例，这个配置类实例非常重要，主要作用包括：
读取配置文件，包括基础配置文件和映射文件
初始化基础配置，比如 MyBatis 的别名，还有其它的一些重要的类对象，像插件、映射器、ObjectFactory 等等
提供一个单例，作为会话工厂构建的重要参数
它的构建过程也会初始化一些环境变量，比如数据源

构建 SqlSessionFactory
SqlSessionFactory 只是一个接口，构建出来的实际上是它的实现类的实例，一般我们用的都是它的实现类 DefaultSqlSessionFactory，


会话运行是 MyBatis 最复杂的部分，它的运行离不开四大组件的配合：
Executor（执行器）
StatementHandler（数据库会话器）
ParameterHandler （参数处理器）
ResultSetHandler（结果处理器）

读取 MyBatis 配置文件——mybatis-config.xml 、加载映射文件——映射文件即 SQL 映射文件，文件中配置了操作数据库的 SQL 语句。最后生成一个配置对象。
构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。
创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。
Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。
StatementHandler：数据库会话器，串联起参数映射的处理和运行结果映射的处理。
参数处理：对输入参数的类型进行处理，并预编译。
结果处理：对返回结果的类型进行处理，根据对象映射规则，返回相应的对象。

我们一般把 Mybatis 的功能架构分为三层：
API 接口层：提供给外部使用的接口 API，开发人员通过这些本地 API 来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。
数据处理层：负责具体的 SQL 查找、SQL 解析、SQL 执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。
基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。

12、为什么 Mapper 接口不需要实现类？
四个字回答：动态代理，我们来看一下获取 Mapper 的过程：

13、Java 数据库连接（JDBC）是一个用于执行 SQL 语句的 Java API，它为多种关系数据库提供了统一访问的机制。使用 JDBC 操作数据库通常涉及以下步骤：

第一步，加载数据库驱动
第二步，建立数据库连接
第三步，创建Statement对象
第四步，执行 SQL 语句
第五步，处理结果集
第六步，关闭资源

创建连接拿到的是什么对象？
在 JDBC 的执行步骤中，创建连接后拿到的对象是java.sql.Connection对象。这个对象是 JDBC API 中用于表示数据库连接的接口，它提供了执行 SQL 语句、管理事务等一系列操作的方法。

什么是 SQL 注入？如何防止 SQL 注入？
SQL 注入是一种代码注入技术，通过在输入字段中插入专用的 SQL 语句，从而欺骗数据库执行恶意 SQL，以获取敏感数据、修改数据，或者删除数据等。

为了防止 SQL 注入，可以采取以下措施：

①、使用参数化查询
②、限制用户输入
③、使用 ORM 框架















