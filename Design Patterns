设计模式是软件工程中常用的解决特定问题的模版或者蓝图，可以帮助我们开发者以一种更加清晰、高效和可重用的方式来编写代码。通常分为三类：

1、创建型模式：涉及对象实例化，用于创建对象的模式，可以增加程序的灵活性和可重用性。常见的创建型模式有工厂方法、抽象工厂、单例、建造者、原型等。
2、结构型模式：涉及类和对象的组合，用于设计类和对象的结构，以便更好地实现程序的功能。常见的结构型模式有适配器、桥接、组合、装饰、外观、享元、代理等。
3、行为型模式：关注对象之间的通信，包括责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者等。



1、什么是责任链模式？
责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，它使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。
请求会沿着一条链传递，直到有一个对象处理它为止。这种模式常用于处理不同类型的请求以及在不确定具体接收者的情况下将请求传递给多个对象中的一个。

工作流程
客户端将请求发送给链上的第一个处理者对象。
处理者接收到请求后，决定自己是否有能力进行处理。
如果可以处理，就处理请求。
如果不能处理，就将请求转发给链上的下一个处理者。
过程重复，直到链上的某个处理者能处理该请求或者链上没有更多的处理者。

应用场景
有多个对象可以处理同一请求，但具体由哪个对象处理则在运行时动态决定。
在不明确指定接收者的情况下，向多个对象中的一个提交请求。
需要动态组织和管理处理者时。

优缺点
优点：

降低耦合度：它将请求的发送者和接收者解耦。
增加了给对象指派职责的灵活性：可以在运行时动态改变链中的成员或调整它们的次序。
可以方便地增加新的处理类，在不影响现有代码的情况下扩展功能。
缺点：

请求可能不会被处理：如果没有任何处理者处理请求，它可能会达到链的末端并被丢弃。
性能问题：一个请求可能会在链上进行较长的遍历，影响性能。
调试困难：特别是在链较长时，调试可能会比较麻烦。


2、什么是工厂模式？

工厂模式（Factory Pattern）属于创建型设计模式，主要用于创建对象，而不暴露创建对象的逻辑给客户端。其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。

举例来说，卡车 Truck 和轮船 Ship 都必须实现运输工具 Transport 接口，该接口声明了一个名为 deliver 的方法。卡车都实现了 deliver 方法，但是卡车的 deliver 是在陆地上运输，而轮船的 deliver 是在海上运输。

工厂模式的主要类型
①、简单工厂模式（Simple Factory）：它引入了创建者的概念，将实例化的代码从应用程序的业务逻辑中分离出来。简单工厂模式包括一个工厂类，它提供一个方法用于创建对象。
②、工厂方法模式（Factory Method）：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类进行。

应用场景
数据库访问层（DAL）组件：工厂方法模式适用于数据库访问层，其中需要根据不同的数据库（如MySQL、PostgreSQL、Oracle）创建不同的数据库连接。工厂方法可以隐藏这些实例化逻辑，只提供一个统一的接口来获取数据库连接。
日志记录：当应用程序需要实现多种日志记录方式（如向文件记录、数据库记录或远程服务记录）时，可以使用工厂模式来设计一个灵活的日志系统，根据配置或环境动态决定具体使用哪种日志记录方式。

3、什么是单例模式？
单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取该实例。单例模式主要用于控制对某些共享资源的访问，例如配置管理器、连接池、线程池、日志对象等。

实现单例模式的关键点？
私有构造方法：确保外部代码不能通过构造器创建类的实例。
私有静态实例变量：持有类的唯一实例。
公有静态方法：提供全局访问点以获取实例，如果实例不存在，则在内部创建。


常见的单例模式实现？
①、饿汉式如何实现单例？
饿汉式单例（Eager Initialization）在类加载时就急切地创建实例，不管你后续用不用得到，这也是饿汉式的来源，简单但不支持延迟加载实例。

②、懒汉式如何实现单例？
懒汉式单例（Lazy Initialization）在实际使用时才创建实例，“确实懒”（😂）。这种实现方式需要考虑线程安全问题，因此一般会带上 synchronized 关键字。

③、双重检查锁如何实现单例？
双重检查锁用 synchronized 同步代码块替代了 synchronized 同步方法。并且在 instance 前加上 volatile 关键字，防止指令重排，因为 instance = new Singleton() 并不是一个原子操作，可能会被重排序，导致其他线程获取到未初始化完成的实例。

④、静态内部类如何实现单例？
利用 Java 的静态内部类（Static Nested Class）和类加载机制来实现线程安全的延迟初始化。

⑤、枚举如何实现单例？
使用枚举（Enum）实现单例是最简单的方式，不仅不需要考虑线程同步问题，还能防止反射攻击和序列化问题。

单例模式的好处有哪些？
单例模式能确保一个类仅有一个实例，并提供一个全局访问点来访问这个实例。这对于需要控制资源使用或需要共享资源的情况非常有用，比如数据库连接池，通过单例模式，可以避免对资源的重复创建和销毁，从而提高资源利用率和系统性能。

单例模式有几种实现方式？
单例模式有 5 种实现方式，常见的有饿汉式、懒汉式、双重检查锁定、静态内部类和枚举。

4、了解哪些设计模式？
单例模式、策略模式和工厂模式。

在需要控制资源访问，如配置管理、连接池管理时经常使用单例模式。它确保了全局只有一个实例，并提供了一个全局访问点。

在有多种算法或策略可以切换使用的情况下，我会使用策略模式。像技术派实战项目中，我就使用策略模式对接了讯飞星火、OpenAI、智谱 AI 等多家大模型，实现了一个可以自由切换大模型基座的智能助手服务。策略模式的好处是，不用在代码中写 if/else 判断，而是将不同的 AI 服务封装成不同的策略类，通过工厂模式创建不同的 AI 服务实例，从而实现 AI 服务的动态切换。后面想添加新的 AI 服务，只需要增加一个新的策略类，不需要修改原有代码，这样就提高了代码的可扩展性。

5、什么是策略模式？
策略模式是一种行为型设计模式，它定义了一系列的算法，将每个算法封装起来，使得它们可以相互替换。这种模式通常用于实现不同的业务规则，其中每种策略封装了特定的行为或算法。

在策略模式中，有三个角色：上下文、策略接口和具体策略。

策略接口：定义所有支持算法的公共接口。
具体策略：实现策略接口的类，提供具体的算法实现。
上下文：使用策略的类。通常包含一个引用指向策略接口，可以在运行时改变其具体策略。











































































