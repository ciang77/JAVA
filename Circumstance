1、你是后端，如果前端调你的接口的时候，响应很慢，如何快速排查
1️⃣确认问题范围
单接口慢还是整体慢
前端慢还是后端慢
是否特定条件/参数导致慢

2️⃣ 日志排查
打印接口耗时日志（入口、业务处理、返回）
使用链路追踪（Sleuth/Zipkin/Jaeger）定位慢环节

3️⃣ 数据库排查
检查慢 SQL，使用 EXPLAIN 分析
检查索引和表结构
确认连接池是否充足

4️⃣ 第三方服务
检查外部接口响应时间
判断是否可异步处理

5️⃣ 代码性能
使用 profiler 分析热点方法耗时
检查锁、事务、并发问题
优化大对象序列化/反序列化

6️⃣ 缓存优化
热点数据是否命中 Redis 或本地缓存
注意缓存穿透/雪崩/击穿问题

7️⃣ 网络和部署
检查服务器 CPU、内存、IO 使用
负载均衡和实例压力
网络延迟

2、redis和mysql区别是什么？
1️⃣ 数据模型与存储方式
MySQL 是关系型数据库，数据以表格形式存储，字段类型固定，依赖磁盘持久化，保证强一致性。
Redis 是键值型数据库，数据以字符串、哈希、列表、集合、有序集合等多种数据结构存储，主要存放在内存中，可选择持久化到磁盘，访问速度极快。

2️⃣ 性能特点
MySQL 在处理复杂查询、多表 JOIN 或事务时性能较好，但受磁盘 IO 和事务锁开销影响。
Redis 基于内存和单线程事件循环，读写速度非常快，适合高并发访问场景。

3️⃣ 查询与功能
MySQL 支持 SQL 查询、事务、外键约束和触发器，适合保证数据完整性。
Redis 主要通过 key 查询，部分数据结构支持复杂操作，如排行榜、计数器，但不支持外键约束，事务隔离性弱。

4️⃣ 典型应用场景
MySQL：适用于用户信息表、订单、账单、财务数据等需要严格一致性和复杂关系的数据。
Redis：适用于热点数据缓存、排行榜、计数器、消息队列、分布式锁等对速度要求高的场景。

3、MySQL 索引的作用可以总结如下：
加快查询速度：索引像书籍目录，能快速定位数据，避免全表扫描。
优化排序与分组：对 ORDER BY 和 GROUP BY 的列建立索引，可减少排序开销。
提高多表 JOIN 效率：关联字段建索引，能加速表连接查询。
保证数据唯一性：主键或唯一索引防止重复数据，提高数据完整性。
支持全文检索：FULLTEXT 索引加速模糊匹配或全文搜索。

4、GET 和 POST 请求的区别可以归纳如下：
参数传递
GET：参数附在 URL 后，长度有限，浏览器可见。
POST：参数放在请求体中，可传输大数据，浏览器不可见。

功能用途
GET：获取资源，安全且幂等，多次请求结果相同。
POST：提交数据或修改服务器状态，不幂等，多次请求可能不同。

缓存与分享
GET：可以缓存，可加入书签或分享。
POST：通常不缓存，不适合书签或分享。

安全性
GET：参数暴露在 URL 中，不适合传递敏感信息。
POST：参数在请求体中，相对安全，但仍需 HTTPS。

除了get和post请求还有以下请求：
PUT：用于 更新资源，通常需要提供完整资源内容，幂等（多次执行结果相同）。
PATCH：用于 部分更新资源，只修改指定字段，不改变其他部分。
DELETE：用于 删除资源，幂等（多次执行结果相同）。
HEAD：获取资源的 响应头信息，不返回响应体，常用于检查资源存在或获取元数据。
OPTIONS：查询服务器支持的请求方法和通信选项，常用于 CORS 跨域请求。
TRACE：回显服务器收到的请求，用于诊断请求链路。
CONNECT：用于代理服务器建立网络连接（如 HTTPS 隧道）。

5、mysql事务隔离级别你是怎么使用的

READ UNCOMMITTED：极少使用，只在可以容忍脏读的场景下提高速度。
READ COMMITTED：适合统计或日志类查询，允许不可重复读，提升并发。
SERIALIZABLE：保证完全一致性，但并发性能差，慎用。
默认 REPEATABLE READ：适合大部分业务，如订单、库存管理，可防止不可重复读。

6、MVCC 了解吗？
MVCC 指的是多版本并发控制，每次修改数据时，都会生成一个新的版本，而不是直接在原有数据上进行修改。并且每个事务只能看到在它开始之前已经提交的数据版本。
这样的话，读操作就不会阻塞写操作，写操作也不会阻塞读操作，从而避免加锁带来的性能损耗。
其底层实现主要依赖于 Undo Log 和 Read View。
每次修改数据前，先将记录拷贝到Undo Log
每次读取数据时，都会生成一个 ReadView，









