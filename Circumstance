1、你是后端，如果前端调你的接口的时候，响应很慢，如何快速排查
1️⃣确认问题范围
单接口慢还是整体慢
前端慢还是后端慢
是否特定条件/参数导致慢

2️⃣ 日志排查
打印接口耗时日志（入口、业务处理、返回）
使用链路追踪（Sleuth/Zipkin/Jaeger）定位慢环节

3️⃣ 数据库排查
检查慢 SQL，使用 EXPLAIN 分析
检查索引和表结构
确认连接池是否充足

4️⃣ 第三方服务
检查外部接口响应时间
判断是否可异步处理

5️⃣ 代码性能
使用 profiler 分析热点方法耗时
检查锁、事务、并发问题
优化大对象序列化/反序列化

6️⃣ 缓存优化
热点数据是否命中 Redis 或本地缓存
注意缓存穿透/雪崩/击穿问题

7️⃣ 网络和部署
检查服务器 CPU、内存、IO 使用
负载均衡和实例压力
网络延迟

2、redis和mysql区别是什么？
1️⃣ 数据模型与存储方式
MySQL 是关系型数据库，数据以表格形式存储，字段类型固定，依赖磁盘持久化，保证强一致性。
Redis 是键值型数据库，数据以字符串、哈希、列表、集合、有序集合等多种数据结构存储，主要存放在内存中，可选择持久化到磁盘，访问速度极快。

2️⃣ 性能特点
MySQL 在处理复杂查询、多表 JOIN 或事务时性能较好，但受磁盘 IO 和事务锁开销影响。
Redis 基于内存和单线程事件循环，读写速度非常快，适合高并发访问场景。

3️⃣ 查询与功能
MySQL 支持 SQL 查询、事务、外键约束和触发器，适合保证数据完整性。
Redis 主要通过 key 查询，部分数据结构支持复杂操作，如排行榜、计数器，但不支持外键约束，事务隔离性弱。

4️⃣ 典型应用场景
MySQL：适用于用户信息表、订单、账单、财务数据等需要严格一致性和复杂关系的数据。
Redis：适用于热点数据缓存、排行榜、计数器、消息队列、分布式锁等对速度要求高的场景。

3、MySQL 索引的作用可以总结如下：
加快查询速度：索引像书籍目录，能快速定位数据，避免全表扫描。
优化排序与分组：对 ORDER BY 和 GROUP BY 的列建立索引，可减少排序开销。
提高多表 JOIN 效率：关联字段建索引，能加速表连接查询。
保证数据唯一性：主键或唯一索引防止重复数据，提高数据完整性。
支持全文检索：FULLTEXT 索引加速模糊匹配或全文搜索。

4、GET 和 POST 请求的区别可以归纳如下：
参数传递
GET：参数附在 URL 后，长度有限，浏览器可见。
POST：参数放在请求体中，可传输大数据，浏览器不可见。

功能用途
GET：获取资源，安全且幂等，多次请求结果相同。
POST：提交数据或修改服务器状态，不幂等，多次请求可能不同。

缓存与分享
GET：可以缓存，可加入书签或分享。
POST：通常不缓存，不适合书签或分享。

安全性
GET：参数暴露在 URL 中，不适合传递敏感信息。
POST：参数在请求体中，相对安全，但仍需 HTTPS。

除了get和post请求还有以下请求：
PUT：用于 更新资源，通常需要提供完整资源内容，幂等（多次执行结果相同）。
PATCH：用于 部分更新资源，只修改指定字段，不改变其他部分。
DELETE：用于 删除资源，幂等（多次执行结果相同）。
HEAD：获取资源的 响应头信息，不返回响应体，常用于检查资源存在或获取元数据。
OPTIONS：查询服务器支持的请求方法和通信选项，常用于 CORS 跨域请求。
TRACE：回显服务器收到的请求，用于诊断请求链路。
CONNECT：用于代理服务器建立网络连接（如 HTTPS 隧道）。

5、mysql事务隔离级别你是怎么使用的

READ UNCOMMITTED：极少使用，只在可以容忍脏读的场景下提高速度。
READ COMMITTED：适合统计或日志类查询，允许不可重复读，提升并发。
SERIALIZABLE：保证完全一致性，但并发性能差，慎用。
默认 REPEATABLE READ：适合大部分业务，如订单、库存管理，可防止不可重复读。

6、MVCC 了解吗？
MVCC 指的是多版本并发控制，每次修改数据时，都会生成一个新的版本，而不是直接在原有数据上进行修改。并且每个事务只能看到在它开始之前已经提交的数据版本。
这样的话，读操作就不会阻塞写操作，写操作也不会阻塞读操作，从而避免加锁带来的性能损耗。
其底层实现主要依赖于 Undo Log 和 Read View。
每次修改数据前，先将记录拷贝到Undo Log
每次读取数据时，都会生成一个 ReadView，

7、redis的热key，怎么解决热key
所谓的热 Key，就是指在很短时间内被频繁访问的键。比如电商大促期间爆款商品的详情信息，流量明星爆瓜时的个人资料、热门话题等，都可能成为热Key。
由于 Redis 是单线程模型，大量请求集中到同一个键会导致该 Redis 节点的 CPU 使用率飙升，响应时间变长。
在 Redis 集群环境下，热Key 还会导致数据分布不均衡，某个节点承受的压力过大而其他节点相对空闲。
更严重的情况是，当热Key 过期或被误删时，会引发缓存击穿问题

最有效的解决方法是增加本地缓存，将热 Key 缓存到本地内存中，这样请求就不需要访问 Redis 了。
对于一些特别热的 Key，可以将其拆分成多个子 Key，然后随机分布到不同的 Redis 节点上。读取时随机选择其中一个。

8、JVM的内存结构？垃圾回收算法？
JVM 大致可以划分为三个部分：类加载器、运行时数据区和执行引擎。
① 类加载器，负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。
② 运行时数据区，JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照 Java 虚拟机规范可以划分为方法区、堆、虚拟机栈、程序计数器和本地方法栈。
③ 执行引擎，也是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器、即时编译器 JIT 和垃圾回收器。

按照 Java 虚拟机规范，JVM 的内存区域可以细分为程序计数器、虚拟机栈、本地方法栈、堆和方法区。


垃圾回收就是对内存堆中已经死亡的或者长时间没有使用的对象进行清除或回收。
JVM 在做 GC 之前，会先搞清楚什么是垃圾，什么不是垃圾，通常会通过可达性分析算法来判断对象是否存活。
在确定了哪些垃圾可以被回收后，垃圾收集器（如 CMS、G1、ZGC）要做的事情就是进行垃圾回收，可以采用标记清除算法、复制算法、标记整理算法、分代收集算法等。
Java 的垃圾回收过程主要分为标记存活对象、清除无用对象、以及内存压缩/整理三个阶段。不同的垃圾回收器在执行这些步骤时会采用不同的策略和算法。

垃圾收集算法
垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。
标记-清除算法分为两个阶段：标记：标记所有需要回收的对象，清除：回收所有被标记的对象
标记-复制算法可以解决标记-清除算法的内存碎片问题，因为它将内存空间划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后清理掉这一块。
说说标记-整理算法标记-整理算法是标记-清除复制算法的升级版，它不再划分内存空间，而是将存活的对象向内存的一端移动，然后清理边界以外的内存。













