1、你是后端，如果前端调你的接口的时候，响应很慢，如何快速排查
1️⃣确认问题范围
单接口慢还是整体慢
前端慢还是后端慢
是否特定条件/参数导致慢

2️⃣ 日志排查
打印接口耗时日志（入口、业务处理、返回）
使用链路追踪（Sleuth/Zipkin/Jaeger）定位慢环节

3️⃣ 数据库排查
检查慢 SQL，使用 EXPLAIN 分析
检查索引和表结构
确认连接池是否充足

4️⃣ 第三方服务
检查外部接口响应时间
判断是否可异步处理

5️⃣ 代码性能
使用 profiler 分析热点方法耗时
检查锁、事务、并发问题
优化大对象序列化/反序列化

6️⃣ 缓存优化
热点数据是否命中 Redis 或本地缓存
注意缓存穿透/雪崩/击穿问题

7️⃣ 网络和部署
检查服务器 CPU、内存、IO 使用
负载均衡和实例压力
网络延迟

2、redis和mysql区别是什么？
1️⃣ 数据模型与存储方式
MySQL 是关系型数据库，数据以表格形式存储，字段类型固定，依赖磁盘持久化，保证强一致性。
Redis 是键值型数据库，数据以字符串、哈希、列表、集合、有序集合等多种数据结构存储，主要存放在内存中，可选择持久化到磁盘，访问速度极快。

2️⃣ 性能特点
MySQL 在处理复杂查询、多表 JOIN 或事务时性能较好，但受磁盘 IO 和事务锁开销影响。
Redis 基于内存和单线程事件循环，读写速度非常快，适合高并发访问场景。

3️⃣ 查询与功能
MySQL 支持 SQL 查询、事务、外键约束和触发器，适合保证数据完整性。
Redis 主要通过 key 查询，部分数据结构支持复杂操作，如排行榜、计数器，但不支持外键约束，事务隔离性弱。

4️⃣ 典型应用场景
MySQL：适用于用户信息表、订单、账单、财务数据等需要严格一致性和复杂关系的数据。
Redis：适用于热点数据缓存、排行榜、计数器、消息队列、分布式锁等对速度要求高的场景。

3、MySQL 索引的作用可以总结如下：
加快查询速度：索引像书籍目录，能快速定位数据，避免全表扫描。
优化排序与分组：对 ORDER BY 和 GROUP BY 的列建立索引，可减少排序开销。
提高多表 JOIN 效率：关联字段建索引，能加速表连接查询。
保证数据唯一性：主键或唯一索引防止重复数据，提高数据完整性。
支持全文检索：FULLTEXT 索引加速模糊匹配或全文搜索。

4、GET 和 POST 请求的区别可以归纳如下：
参数传递
GET：参数附在 URL 后，长度有限，浏览器可见。
POST：参数放在请求体中，可传输大数据，浏览器不可见。

功能用途
GET：获取资源，安全且幂等，多次请求结果相同。
POST：提交数据或修改服务器状态，不幂等，多次请求可能不同。

缓存与分享
GET：可以缓存，可加入书签或分享。
POST：通常不缓存，不适合书签或分享。

安全性
GET：参数暴露在 URL 中，不适合传递敏感信息。
POST：参数在请求体中，相对安全，但仍需 HTTPS。

除了get和post请求还有以下请求：
PUT：用于 更新资源，通常需要提供完整资源内容，幂等（多次执行结果相同）。
PATCH：用于 部分更新资源，只修改指定字段，不改变其他部分。
DELETE：用于 删除资源，幂等（多次执行结果相同）。
HEAD：获取资源的 响应头信息，不返回响应体，常用于检查资源存在或获取元数据。
OPTIONS：查询服务器支持的请求方法和通信选项，常用于 CORS 跨域请求。
TRACE：回显服务器收到的请求，用于诊断请求链路。
CONNECT：用于代理服务器建立网络连接（如 HTTPS 隧道）。

5、mysql事务隔离级别你是怎么使用的

READ UNCOMMITTED：极少使用，只在可以容忍脏读的场景下提高速度。
READ COMMITTED：适合统计或日志类查询，允许不可重复读，提升并发。
SERIALIZABLE：保证完全一致性，但并发性能差，慎用。
默认 REPEATABLE READ：适合大部分业务，如订单、库存管理，可防止不可重复读。

6、MVCC 了解吗？
MVCC 指的是多版本并发控制，每次修改数据时，都会生成一个新的版本，而不是直接在原有数据上进行修改。并且每个事务只能看到在它开始之前已经提交的数据版本。
这样的话，读操作就不会阻塞写操作，写操作也不会阻塞读操作，从而避免加锁带来的性能损耗。
其底层实现主要依赖于 Undo Log 和 Read View。
每次修改数据前，先将记录拷贝到Undo Log
每次读取数据时，都会生成一个 ReadView，

7、redis的热key，怎么解决热key
所谓的热 Key，就是指在很短时间内被频繁访问的键。比如电商大促期间爆款商品的详情信息，流量明星爆瓜时的个人资料、热门话题等，都可能成为热Key。
由于 Redis 是单线程模型，大量请求集中到同一个键会导致该 Redis 节点的 CPU 使用率飙升，响应时间变长。
在 Redis 集群环境下，热Key 还会导致数据分布不均衡，某个节点承受的压力过大而其他节点相对空闲。
更严重的情况是，当热Key 过期或被误删时，会引发缓存击穿问题

最有效的解决方法是增加本地缓存，将热 Key 缓存到本地内存中，这样请求就不需要访问 Redis 了。
对于一些特别热的 Key，可以将其拆分成多个子 Key，然后随机分布到不同的 Redis 节点上。读取时随机选择其中一个。

8、JVM的内存结构？垃圾回收算法？
JVM 大致可以划分为三个部分：类加载器、运行时数据区和执行引擎。
① 类加载器，负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。
② 运行时数据区，JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域按照 Java 虚拟机规范可以划分为方法区、堆、虚拟机栈、程序计数器和本地方法栈。
③ 执行引擎，也是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器、即时编译器 JIT 和垃圾回收器。

按照 Java 虚拟机规范，JVM 的内存区域可以细分为程序计数器、虚拟机栈、本地方法栈、堆和方法区。


垃圾回收就是对内存堆中已经死亡的或者长时间没有使用的对象进行清除或回收。
JVM 在做 GC 之前，会先搞清楚什么是垃圾，什么不是垃圾，通常会通过可达性分析算法来判断对象是否存活。
在确定了哪些垃圾可以被回收后，垃圾收集器（如 CMS、G1、ZGC）要做的事情就是进行垃圾回收，可以采用标记清除算法、复制算法、标记整理算法、分代收集算法等。
Java 的垃圾回收过程主要分为标记存活对象、清除无用对象、以及内存压缩/整理三个阶段。不同的垃圾回收器在执行这些步骤时会采用不同的策略和算法。

垃圾收集算法
垃圾收集算法主要有三种，分别是标记-清除算法、标记-复制算法和标记-整理算法。
标记-清除算法分为两个阶段：标记：标记所有需要回收的对象，清除：回收所有被标记的对象
标记-复制算法可以解决标记-清除算法的内存碎片问题，因为它将内存空间划分为两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后清理掉这一块。
说说标记-整理算法标记-整理算法是标记-清除复制算法的升级版，它不再划分内存空间，而是将存活的对象向内存的一端移动，然后清理边界以外的内存。

9、什么是循环依赖?
简单来说就是两个或多个 Bean 相互依赖，比如说 A 依赖 B，B 依赖 A，或者 C 依赖 C，就成了循环依赖。

Spring 通过三级缓存机制来解决循环依赖：

一级缓存：存放完全初始化好的单例 Bean。
二级缓存：存放提前暴露的 Bean，实例化完成，但未初始化完成。
三级缓存：存放 Bean 工厂，用于生成提前暴露的 Bean。

10、你用过线程池没有，在哪里用到的
在我们的系统中，我使用过 Java 的线程池（ThreadPoolExecutor / Spring TaskExecutor） 来处理异步任务和高并发场景。典型场景包括：
异步文档处理：用户上传大文件时，不希望阻塞主线程，我将解析和向量化任务提交到线程池异步执行，前端立即返回任务提交成功。
接口并行调用：在内网接口首次请求慢的场景，我用 CompletableFuture + 线程池并行化多个模板字段请求，加快整体响应速度。
消息队列消费者：RocketMQ 或 Kafka 的消费者处理高并发消息时，将每条消息或批量消息交给线程池执行，提高吞吐量，同时控制并发数避免资源耗尽。
通过线程池，我可以复用线程、控制并发数、避免频繁创建销毁线程带来的开销，同时提升系统响应速度和稳定性

11、有没有遇到过死锁？怎么解决的？
在我们的项目中，我在处理异步任务、线程池和消息队列消费者时，非常注意死锁问题。虽然实际项目中没有发生过死锁，但我们采取了多种措施来防止：首先，在多线程或异步任务中尽量 避免嵌套锁和跨模块锁，
减少循环依赖；其次，控制锁粒度，只锁必要资源，避免线程长时间持有锁；再者，对于可能阻塞的操作，我们设置了 超时机制，例如 CompletableFuture 或线程池任务可以超时取消，避免无限等待；最后，在分布式场景下，
使用 Redis 或 RocketMQ 消息队列异步处理耗时任务，将高耗时操作从主线程剥离，也进一步降低了死锁风险。通过这些措施，我们保证了系统在高并发和异步处理下依然稳定运行。

12、接触过反射没，在哪接触到的？
我在项目中确实接触过反射。最直接的理解是它可以 ‘暴力’ 获取私有字段或方法，用于一些特殊场景的动态操作。更常见的是在 Spring 框架中广泛使用反射，比如注解解析、依赖注入、AOP 代理等。结合我的项目，
例如在 Spring Boot 中使用自定义注解实现接口拦截器或者异步任务标记时，底层都是通过反射去扫描注解并执行对应逻辑。通过这种方式，我们能够在不修改业务代码的情况下动态增强功能，保证系统的可扩展性和灵活性。

除了注解解析，反射在项目中还用于动态创建对象、动态调用方法、JSON/对象映射以及 Spring AOP 代理等场景。比如接口拦截器和异步任务执行，都是通过反射获取方法信息或注解，再动态执行逻辑，实现功能增强和灵活扩展。

13、spring里面的依赖注入了解没？
依赖注入的定义：
依赖注入是一种将类所依赖的对象（依赖项）从外部传入，而不是由类自己去创建或获取对象的方式。这样可以让类专注于自己的核心功能，而不需要关注如何管理其依赖对象。

DI 的优势：
解耦：通过 DI，类不再依赖于具体的实现，而是依赖于接口或抽象，增强了系统的灵活性和可扩展性。
便于测试：DI 使得依赖项可以容易地替换为 mock 对象或假实现，提高了单元测试的效率。
代码可维护性：减少了类之间的耦合，使得修改或扩展某个类时，不会影响到其他类。
提高可配置性：通过 Spring 容器管理 Bean，可以灵活地进行 Bean 的配置和切换。

Spring 提供了三种主要的依赖注入方式：
构造器注入（Constructor Injection）：通过构造函数注入依赖，Spring 会在实例化对象时，自动将所需的依赖传入构造函数。
Setter 注入（Setter Injection）：通过 setter 方法注入依赖。Spring 会调用对应的 setter 方法来注入依赖。
字段注入（Field Injection）：直接在字段上使用 @Autowired 注解，Spring 会自动注入该字段所需要的依赖。

14、如果我是一个新手，你如何向我介绍哈希表，哈希表是用来干什么的？
哈希表（Hash Table）是一种常用的数据结构，它通过哈希函数将键（Key）映射到固定大小的数组索引上，从而实现高效的数据存储和查找。哈希表的核心思想是将数据存储为“键-值”对，允许我们通过给定的键迅速访问对应的值。

哈希表的优点：
查找效率高：在理想情况下，哈希表的查找时间为 O(1)，因此非常适合需要快速查找的场景。
数据存储灵活：哈希表使用键值对的形式存储数据，能够有效支持各种基于键的查询。

应用场景：
缓存：例如，存储计算结果，避免重复计算。
数据库索引：快速查找记录。
去重操作：例如在一个集合中去除重复的元素。

15、liunx系统里面查看资源消耗的命令是什么？就类似Windows里面的任务管理器
top / htop：查看实时系统资源使用情况。
free：查看内存使用情况。
ps：查看进程的资源消耗。
iostat / vmstat：查看磁盘和 CPU 使用情况。
netstat / ss：查看网络连接情况。










