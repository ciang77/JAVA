1、Java引用拷贝、浅拷贝、深拷贝区别是什么？

引用拷贝（Reference Copy）
在Java中，当你将一个对象的引用赋值给另一个变量时，实际上是创建了一个新的引用，这个新引用指向了原始对象相同的内存地址。这意味着两个引用实际上共享同一个对象实例。任何通过任一引用对对象属性的修改都会影响到另一个引用所看到的对象状态。

浅拷贝（Shallow Copy）
浅拷贝是指创建一个新的对象，并将原始对象的非静态字段复制到新对象中。对于基本数据类型的字段，会直接复制其值；而对于引用类型的字段，则会复制引用本身，而不是引用指向的对象。因此，原始对象和副本中的引用类型字段仍然指向同一个对象实例。

实现方式：
实现Cloneable接口并重写clone()方法。
使用构造函数进行复制（需要手动复制每个字段）。

深拷贝（Deep Copy）
深拷贝不仅复制对象本身，还会递归地复制所有嵌套的对象，使得原始对象和副本之间没有任何共享的引用。这样可以确保原始对象和副本是完全独立的，修改其中一个不会影响另一个。

实现方式：
手动实现：为每个引用类型的字段提供相应的复制逻辑。
序列化：使用Serializable接口，通过序列化和反序列化来实现深拷贝。
第三方库：如Apache Commons Lang的SerializationUtils.clone()或Google Guava的Objects.firstNonNull()等。

引用拷贝：只复制引用，不复制实际对象，两个引用指向同一对象。
浅拷贝：复制对象本身，但对于引用类型的成员变量，只是复制了引用，未复制引用指向的对象。
深拷贝：递归复制对象及其所有引用类型的成员变量，确保原始对象和副本完全独立。

2、java中的自动拆箱和自动装箱

基本理解：装箱就是自动将基本数据类型转换为封装类型，拆箱就是自动将封装类型转换为基本数据类型。
装箱的时候其实就是自动调用了Integer的valueOf(int)方法。
在拆箱的时候调用了Integer对象的intValue()方法。包装类在装箱时，将我们传入的int型参数value保存起来且私有不能被改变，在拆箱时利用intValue()方法返回int型的value值。
据IntegerCache私有静态类的源码可以发现，当数值不在[127~Integer.MAX_VALUE - (-low) -1]即[-128,127]之间时，便会创建新的Integer对象。

public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;

        Integer one=new Integer(100);
        Integer two=new Integer(100);
        System.out.println(i1==i2);   //1-true
        System.out.println(i3==i4);   //2-false    
        System.out.println(one==two);  //3-false
        System.out.println(i1==100);   //4-true
        System.out.println(i1==one);   //5-false
        

    }

1，true，上面的代码中i1和i2的数值为100，且被Integer包装类包装起来，因此直接从IntegerCache私有静态类的Integer数组中取已经存在的对象。
2，false，这里很多同学容易出错，上面的代码中i3和i4的数值为200，根据IntegerCache私有静态类的源码可以发现，当数值不在[127~Integer.MAX_VALUE - (-low) -1]即[-128,127]之间时，便会创建新的Integer对象。因此这里i3和i4是两个不同对象，因此为false。
3，false，这里就很好理解了，因为new Integer(100);创建了两个不同的对象，==比较的是内存地址。
4，true，这里其实包含两个步骤：1， Integer i1 = 100;进行装箱；2，i1==100自动进行了拆箱，因此这里是两个基本数据类型进行比较，值必然相同。
5，false，i1对象进行了装箱，其是直接从IntegerCache私有静态类的Integer数组中取已经存在的对象。而one是创建了一个新的对象，因此两者的内存地址必然不相同。


3、说一下你对同步和异步的理解
一、同步
同步是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。
特点：顺序性强，阻塞性
使用场景：简单的业务流程，对事务顺序有严格的要求
二、异步
异步是指进程不需要一直等待，而是继续执行下面的操作，当有消息返回时系统会通知进程进行处理，这样可以提高效率。
特点：非阻塞性，并发性高，结果通知机制
使用场景：耗时的IO操作，大规模并发处理


4、进程和线程的区别

进程：

进程是操作系统进行资源分配和调度的基本单位。它代表着一个正在运行的程序实例，包含了程序运行所需的代码、数据、资源（如内存、文件句柄等）。可以把进程想象成一个独立的“工作空间”，每个进程都有自己独立的地址空间，不同进程之间的资源是相互隔离的。例如，同时运行的两个不同的应用程序就是两个不同的进程。

进程占用的资源相对较多。每个进程都有独立的内存空间，这意味着操作系统需要为每个进程分配足够的内存来存储其代码、数据和运行时的堆栈等。
进程还需要独立的文件描述符表、用户 ID 和组 ID 等系统资源。启动一个新进程通常需要较大的开销，包括分配内存、初始化资源等。

进程的调度通常由操作系统内核完成。当一个进程被调度执行时，操作系统会为其分配 CPU 时间片，并在时间片用完或出现更高优先级的进程时进行切换。进程切换的开销较大，因为需要保存和恢复进程的整个上下文，包括内存映像、寄存器状态、文件描述符等。这就像在一个大型工厂中，从一个生产线切换到另一个生产线需要进行大量的准备工作和设备调整。

进程之间的并发性相对较低，因为它们之间的资源是相互隔离的。进程之间的通信通常需要通过操作系统提供的机制，如管道、消息队列、共享内存等。
这些通信机制相对复杂，并且需要进行额外的系统调用和数据复制操作。例如，两个进程通过管道进行通信时，需要将数据从一个进程的输出流复制到管道，再从管道复制到另一个进程的输入流。

由于进程之间的资源是相互隔离的，一个进程的错误通常不会影响到其他进程。这使得进程具有较高的稳定性和安全性。如果一个进程崩溃或出现错误，操作系统可以独立地终止该进程，而不会影响到其他正在运行的进程。


线程：
线程是进程中的一个执行单元。一个进程可以包含多个线程，这些线程共享进程的资源，如内存空间、文件描述符等。线程就像是在一个大的“工作空间”里的小任务执行者，它们协同工作来完成进程的总体任务。比如，一个文字处理软件可能有一个线程用于处理用户输入，另一个线程用于自动保存文档。

线程占用的资源相对较少。由于多个线程共享进程的内存空间和其他资源，所以创建一个新线程比创建一个新进程的开销要小得多。
线程只需要少量的堆栈空间来保存其执行状态，并且可以快速地创建和销毁。

线程的调度也由操作系统内核完成，但由于线程共享进程的资源，所以线程切换的开销相对较小。线程切换只需要保存和恢复线程的执行上下文，如寄存器状态和堆栈指针等。这就好比在一个生产线上，从一个工人切换到另一个工人只需要简单地调整一下工作位置和工具，而不需要对整个生产线进行大规模的调整。

线程之间的并发性较高，因为它们共享进程的资源。线程之间可以直接访问共享的内存空间，这使得它们之间的通信更加方便和高效。例如，一个线程可以直接修改另一个线程可以访问的共享变量，而不需要通过复杂的通信机制。但是，这种直接访问共享资源的方式也需要进行同步和互斥操作，以避免数据竞争和不一致性。

线程之间共享进程的资源，一个线程的错误可能会影响到整个进程的稳定性。例如，如果一个线程访问了非法的内存地址或发生了除零错误，可能会导致整个进程崩溃。因此，在多线程编程中，需要更加小心地处理线程之间的同步和错误处理，以确保程序的稳定性和安全性。

5、重载和重写的区别

重载：
定义：在同一个类中，允许存在多个同名方法，但这些方法的参数列表不同（参数的类型、数量、顺序不同）。
概念：重载主要是为了在同一个作用域内提供多个功能相似但参数不同的方法，以方便程序员根据不同的情况调用合适的方法。例如，可以有多个名为“calculate”的方法，分别用于计算不同类型的数据或者接受不同数量的参数。

作用范围：只在同一个类中有效，不同的类之间不能通过重载来区分方法。

重写：
定义：子类对父类中已经存在的方法进行重新实现，方法名、参数列表和返回值类型必须与父类中被重写的方法完全相同。
概念：重写是面向对象编程中的多态性的一种体现，子类通过重写父类的方法，可以根据自身的特点实现特定的行为，同时保持与父类方法相同的接口。这使得在使用父类引用指向子类对象时，可以根据实际的对象类型动态地调用相应的方法。

作用范围：发生在子类和父类之间，子类通过重写父类的方法来实现自己的特定行为。


6、面向对象的三大特性：封装、继承、多态

封装：封装是将数据和操作这些数据的方法绑定在一起，形成一个类，并通过访问控制机制限制外部对类内部数据和方法的直接访问。目的在于保护数据的安全性和完整性，避免外部代码随意修改内部数据，同时提高代码的可维护性和可扩展性。
作用：保护数据，提高代码的可维护性，隐藏实现细节

继承：继承是一种创建新类的方式，新类（子类）可以继承现有类（父类）的属性和方法，同时可以添加自己的新属性和新方法。目的在于实现代码的复用，减少重复代码的编写，同时建立类之间的层次关系，便于对问题进行抽象和建模。
作用：代码复用，层次结构，是实现多态的基础

多态：多态是指同一个行为具有多种不同的表现形式。在面向对象编程中，多态主要体现在方法的重写和方法的重载，以及通过父类引用调用子类对象的方法。目的在于提高代码的灵活性和可扩展性，使得程序能够根据不同的对象类型自动选择合适的方法进行调用。
作用：灵活性，可扩展性，代码的简洁性


7、什么是java的序列化和反序列化
序列化是将 Java 对象转换为字节序列的过程。这个字节序列可以被存储在文件中、通过网络传输或者保存在数据库中。
目的：是实现对象的持久化存储，使得对象可以在不同的时间和地点被恢复；同时也便于在网络中传输对象，实现分布式系统中的对象通信。
实现方式：Java 中的序列化是通过实现 java.io.Serializable 接口来实现的。一个类实现了这个接口，就表示该类的对象可以被序列化。

反序列化是序列化的逆过程，即将字节序列转换回 Java 对象。通过反序列化，可以从存储介质（如文件、数据库）或网络中读取字节序列，并恢复为原始的 Java 对象。
目的：是从持久化存储或网络传输中获取对象，恢复对象的状态，以便继续进行程序的处理。
实现方式：使用 ObjectInputStream 类进行反序列化。首先创建一个 ObjectInputStream 对象，然后调用其 readObject() 方法读取字节流并反序列化出对象。

安全问题：反序列化过程可能存在安全风险，因为恶意构造的字节流可能导致反序列化漏洞，被攻击者利用执行任意代码。因此，在进行反序列化时，需要谨慎处理输入源，确保其来源可信。
版本兼容性：如果对象的类在序列化和反序列化之间发生了变化，可能会导致反序列化失败。为了保证版本兼容性，可以使用 serialVersionUID 来标识类的版本，或者提供自定义的序列化和反序列化方法。

8、并发和并行的区别
定义：并行是指多个任务在同一时刻同时执行，即多个任务在不同的处理器核心或计算单元上真正地同时运行。
概念：可以想象为多个工人在同一时间各自独立地完成不同的工作任务。例如，在一个拥有多个处理器核心的计算机系统中，多个程序可以同时在不同的核心上运行，每个核心独立地执行一个程序，这就是并行执行。

定义：并发是指多个任务在同一时间段内交替执行，看起来像是同时进行，但实际上在任何一个时刻只有一个任务在执行。
概念：类似于一个工人在不同的任务之间快速切换，给人一种多个任务同时进行的错觉。例如，在单处理器系统中，操作系统通过快速切换不同程序的执行，使得多个程序看起来像是在同时运行，实际上是在不同的时间片段内轮流执行。


并行：
适用于计算密集型任务，如大规模科学计算、图形处理、视频编码等。这些任务通常需要大量的计算资源和时间，通过并行执行可以显著提高处理速度。
例如，在进行大规模的数据分析和机器学习任务时，可以使用分布式计算框架将任务分配到多个计算节点上并行执行，大大缩短计算时间。

并发：
适用于 I/O 密集型任务和需要同时处理多个请求的场景，如 Web 服务器、数据库服务器、网络应用等。这些任务通常需要等待外部输入输出操作完成，在等待期间可以切换到其他任务执行，提高系统的响应性和吞吐量。
例如，在 Web 服务器中，同时处理多个客户端的请求，当一个请求在等待数据库查询结果时，服务器可以切换到处理其他请求，提高服务器的并发处理能力。


9、抽象类和接口的区别

相同点：
都是抽象概念，用于描述类的行为。
都不能被实例化。

不同点：
继承关系：
抽象类是对类的抽象，可以有普通方法和抽象方法。
接口是对行为的抽象，只能有抽象方法和常量。

实现关系：
一个类只能继承一个抽象类，但可以实现多个接口。

强调：
接口强调特定功能的实现，而抽象类强调所属关系。

9、基础数据类型和引用数据类型的区别

基础数据类型：

通常直接存储在栈内存中。栈内存的特点是空间较小但存取速度快，数据的存储和读取效率高。

内存的分配和释放由系统自动管理，当超出其作用域时，系统会自动回收其所占用的内存空间。
例如，在一个方法内部定义的基本数据类型变量，当方法执行完毕后，该变量所占用的栈内存空间会被自动释放。

在方法调用中，基础数据类型是按值传递。这意味着将实参的值复制一份传递给形参，在方法内部对形参的修改不会影响到外部实参的值。
例如，在一个方法中对传入的基本数据类型参数进行修改，方法执行结束后，外部调用处的该变量的值不会发生改变。

引用数据类型：

存储在堆内存中，而在栈内存中存储的是对堆内存中对象的引用地址。

堆内存中的对象内存分配和释放相对复杂。一般来说，需要通过垃圾回收机制来回收不再被引用的对象所占用的内存空间。
当没有任何引用指向一个堆内存中的对象时，在未来的某个时间点，垃圾回收器会识别并回收该对象的内存空间。

引用数据类型是按引用传递。实际上传递的是对象的引用地址，在方法内部对引用所指向的对象进行修改，会影响到外部实际的对象。
比如，将一个对象作为参数传递给一个方法，在方法内部修改该对象的属性值，外部调用处的该对象的属性值也会发生改变。


10、如何实现java多态：
多态主要有两种实现方式：编译时多态和运行时多态。

编译时多态（静态多态）：主要通过方法重载（Overloading）来实现。方法重载是指在同一个类中，定义多个同名但参数列表不同的方法。在编译时，根据参数的不同，编译器会确定调用哪个具体的方法。

运行时多态（动态多态）：主要通过方法重写（Overriding）来实现。方法重写是指子类重新定义父类中已有的方法。当通过子类对象调用该方法时，实际执行的是子类中重写后的方法，而不是父类中的方法。这就实现了在运行时根据对象的实际类型来决定调用哪个方法的多态行为。

11、内存泄露和内存溢出的区别是什么？
内存泄漏（Memory Leak）：

内存泄漏是指程序在申请内存后，无法释放已申请的内存空间。
具体表现为：程序分配了内存，但在使用完毕后没有正确释放，导致这块内存无法再被其他部分使用。
内存泄漏通常是由于代码中的错误、不正确的引用管理或资源未正确关闭等原因导致的。
单次内存泄漏可能不会立即产生严重后果，但如果内存泄漏堆积，最终会耗尽系统的所有内存。

内存溢出（Out of Memory）：

内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，出现“out of memory”错误。
具体表现为：程序要求分配的内存超出了系统能提供的内存大小。
内存溢出会导致程序崩溃或无法正常运行，因为它直接涉及到程序的运行空间不足。

区别：

内存泄漏是占用了不再使用的内存，导致系统无法回收；而内存溢出是申请的内存超出了系统能提供的范围。
内存泄漏可能最终导致内存溢出，因为未释放的内存会不断增加，最终耗尽系统资源。


12、JVM运行时的数据区有哪些

方法区、虚拟机栈、本地方法栈、堆、程序计数器


一、程序计数器（Program Counter Register）

作用：
可以看作是当前线程所执行的字节码的行号指示器。在多线程环境下，每个线程都有自己独立的程序计数器，用于记录该线程正在执行的字节码指令地址，以便线程切换后能恢复到正确的执行位置。

二、Java 虚拟机栈（Java Virtual Machine Stacks）

作用：
用于存储方法调用的栈帧（Stack Frame）。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法返回地址等信息。


三、本地方法栈（Native Method Stacks）

作用：
与虚拟机栈类似，但是用于支持本地方法（Native Method）的执行。本地方法是用其他语言（如 C、C++）实现的方法，在 Java 中可以通过native关键字声明。

四、Java 堆（Java Heap）

作用：
用于存储对象实例和数组。几乎所有的对象实例都在堆上分配内存。堆是垃圾回收的主要区域，JVM 会自动管理堆内存，回收不再使用的对象，以避免内存泄漏。

五、方法区（Method Area）

作用：
存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

13、== 和 equals 的区别是什么？
== 既可以比较基本类型也可以比较引用类型，对于基本类型就是比较值，对于引用类型及时比较内存的地址
equals的话，他是属于java.lang.Object类里面的方法，如果该方法没有被重写过，默认也是== ，通常情况下，重写equals方法，会比较类中的属性是否相等
double只有当小数不能精确表示时才会丢精度。因为 0.1 和 0.2 不能被 double 精确表示，导致加法后产生微小误差。但是像 1.0 这种正好是整数的 double，在 double 中是 可以精确表示的

int a = 1;
double b = 1.0;
System.out.println(a == b);  // true，因为没有丢精度

在表达式a == b	  会自动进行类型转换int -> double



Customer c1 = new Customer("小明", 20);
Customer c2 = new Customer("小明", 20);
System.out.println(c1 == c2);       // false
System.out.println(c1.equals(c2));  // false


== 比较的是 两个对象的地址（引用），所以不同对象返回 false。
默认的 equals() 方法是 Object 类的实现，也是比较地址。
所以如果不重写 equals()，那么 equals() 和 == 是一样的，结果都是 false。

对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，
如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。
        String s1="123"; //在常量池中
        String s2="123";
        System.out.println(s1==s2);  //true
        String s3 = new String("123");  //存储在堆内存中
        System.out.println(s1==s3);


14、final在java中有什么作用

修饰基本数据类型变量：
当用final修饰基本数据类型变量时，该变量就变成了常量，其值在初始化后不能被改变

修饰引用类型变量：
final修饰引用类型变量时，该引用不能再指向其他对象，但对象本身的内容是可以改变的。

修饰方法
当一个方法被final修饰时，这个方法不能在子类中被重写。这可以确保该方法的行为在继承体系中是固定的，不会被意外修改。例如：

修饰类
用final修饰的类不能被继承。这意味着该类的功能是固定的，不能被扩展。例如，java.lang.String类就是final类，以确保字符串的核心行为不会被意外改变。


15、this和super关键字的区别

this关键字的作用
引用当前对象：
在成员方法中，this代表调用该方法的当前对象。可以通过this来访问当前对象的成员变量和成员方法。

作为方法的参数传递当前对象：
可以将当前对象作为参数传递给其他方法

调用本类的其他构造方法：
在一个类的构造方法中，可以使用this来调用同一类中的其他构造方法，必须放在构造方法的第一行。


super 关键字的作用
调用父类的构造方法：
在子类的构造方法中，可以使用super来调用父类的构造方法，必须放在子类构造方法的第一行。这有助于确保在创建子类对象时，先正确地初始化父类部分

访问父类的成员变量和方法：
当子类中定义了与父类同名的成员变量或方法时，可以使用super来明确地访问父类中的成员变量或方法。

16、final 与 static 的区别？

final：
当你希望一个变量的值在初始化后不能被改变，或者一个方法不能被重写，或者一个类不能被继承时，可以使用final。例如，定义常量、防止方法被意外重写以确保特定的行为、或者设计不可扩展的类。
例如，定义数学常量PI可以使用final double PI = 3.14159;

static：
当你希望一个变量或方法与类本身相关而不是与特定的实例相关时，可以使用static。例如，工具类中的方法通常是静态的，因为它们不需要创建类的实例就可以使用。
例如，Math类中的方法都是静态的，如Math.sqrt()用于计算平方根，不需要创建Math类的实例就可以直接调用。

17、char能存储一个中文汉字吗

在 Java 中，char 型变量可以存储一个中文汉字。
Java 中的字符采用 Unicode 编码，char 类型占两个字节，而一个汉字在 Unicode 编码中通常也占两个字节，所以 char 类型可以存储一个汉字。

18、String str="i"与 String str=new String(“i”)一样吗？

String str = “i”：
这种方式是使用字符串字面量创建字符串对象。当在程序中以这种方式创建多个相同内容的字符串时，Java 会使用字符串常量池来管理这些字符串。如果常量池中已经存在内容为“i”的字符串，那么就直接让str指向这个已经存在的字符串对象，不会创建新的对象。

如果常量池中没有“i”这个字符串，会在常量池中创建并存储这个字符串，然后让str指向它。如果已经存在，则直接让str指向已有的字符串，这样可
以节省内存空间。

一般情况下，使用字符串字面量的方式创建字符串性能更好，因为它可以利用常量池的优化机制，避免不必要的对象创建。

String str = new String(“i”)：
这种方式是通过显式地使用构造方法创建字符串对象。无论常量池中是否已经存在内容为“i”的字符串，都会在堆上创建一个新的字符串对象。

一定会在堆上分配新的内存空间来存储这个新创建的字符串对象，即使常量池中已经有相同内容的字符串。

使用构造方法创建字符串相对来说性能稍低，因为会频繁地在堆上创建对象，可能会导致更多的内存分配和垃圾回收操作。

19、“+”连接符的效率为何低？
String采用连接运算符(+)效率低下，都是上述循环、大批量数据情况造成的，每做一次"+"就产生个StringBuilder对象，然后append后就扔掉。下次循环再到达时重新产生个StringBuilder对象，然后append字符串，如此循环直至结束。如果我们直接采用StringBuilder对象进行append的话，我们可以节省创建和销毁对象的时间。如果只是简单的字面量拼接或者很少的字符串拼接，性能都是差不多的。

20、在 Java 中，final、finally和finalize有以下区别：
final是一个关键字，表示最终的、不可改变的。
修饰变量：变量一旦被初始化后其值不能被修改，成为常量。
修饰方法：方法不能被重写。
修饰类：类不能被继承。

finally是用于异常处理的一个关键字，与try-catch语句块一起使用。
无论是否发生异常，finally代码块中的代码一定会被执行。通常用于释放资源等操作，确保一些关键的操作不会因为异常而被忽略。

finalize是Object类中的一个方法。（已过时，不推荐使用）
当垃圾回收器确定不存在对该对象的更多引用时，由垃圾回收器在对象被回收之前调用该方法。但是，由于垃圾回收的不确定性，不能确切地知道finalize方法何时会被调用，甚至不能保证它一定会被调用。并且现代 Java 编程中不建议过度依赖这个方法来进行资源清理，而应该使用try-with-resources语句或在finally块中进行资源清理以确保资源的正确释放。

21、为什么要重写equals和hashCode方法

对于自定义类，如果希望根据对象的内容而不是引用进行相等性判断，就需要重写 equals 方法。默认的 equals 方法（继承自 Object 类）是比较对象的引用，只有当两个引用指向同一个对象时才返回 true。

hashCode 默认的实现方式是为不同的对象生成不同的整数结果，通常是基于对象的内存地址计算得出的哈希码，在哈希集合（如 HashSet、HashMap）中，哈希码用于确定对象的存储位置和快速查找。如果重写了 equals 方法，通常也需要重写 hashCode 方法，以保证相等的对象具有相同的哈希码。

常见错误：
只重写了 equals 方法而忘记重写 hashCode 方法，这可能导致在使用哈希集合时出现不可预期的行为。
在 equals 方法中进行不恰当的比较，比如只比较了部分属性或者使用了不稳定的比较方式。
在 hashCode 方法中生成哈希码的方式不合理，导致不同的对象可能产生相同的哈希码或者相等的对象产生不同的哈希码。

22、你什么时stream流，常用写法是什么？
Stream流在Java中是Java 8引入的一种新特性，它主要用于处理集合数据，提供了声明式的数据处理方式，可以让开发者用更简洁、更直观的代码来操作集合，提升开发效率。

Stream流的特点：

不存储数据：Stream不直接存储数据，只是通过管道操作数据源。
延迟执行：Stream流中的操作大多是惰性操作（lazy evaluation），只有当执行终端操作时，才会真正处理数据。
链式操作：支持链式编程，可以进行多步操作组合，如过滤、映射、排序等。
并行处理：Stream可以轻松地转换为并行流，利用多核处理器的优势提高执行效率。

     List<String> list = Arrays.asList("apple", "banana", "cherry");
     Stream<String> stream = list.stream();

Stream流的使用场景：
过滤数据、数据转换、统计计算等操作。
特别适合对集合类数据的批量处理，提高代码的可读性和开发效率。

23、什么是枚举？他的应用场景
“枚举（Enum）是一种特殊的数据类型，用于定义一组固定的常量集合。在Java中，枚举使用关键字enum定义，背后实际上是一个类，并且所有的枚举值都被当作这个类的实例来处理。与普通常量不同的是，枚举实例在编译时就确定了，不会被更改，因此更安全、可读性更好。

常用场景：表示固定的状态或类型、简化代码的逻辑判断、配合策略模式、数据库字段映射、

特点：每一个枚举都是一个实例，枚举是线程安全的，支持字段方法和构造器，限定的固定常量集合，内置方法，可以实现接口，不允许创建新实例

枚举默认继承了java.lang.Enum类，这是Java的一个内置类。由于Java不支持多重继承，所以枚举类型不能再继承其他类。
枚举类型可以实现一个或多个接口。这意味着你可以为枚举类型定义方法，这些方法必须在枚举的每个实例中具体实现，或者在枚举类型中提供默认实现。































