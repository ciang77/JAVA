什么是进程和线程？进程和线程的区别？
进程是操作系统中资源分配的基本单位，线程是进程中执行的基本单位，进程拥有独立的内存空间，而线程共享进程的内存空间和资源。

区别：
内存空间
进程：拥有独立的内存空间。
线程：共享进程的内存空间。
资源开销
进程：创建和切换开销大。
线程：创建和切换开销小。
通信方式
进程：通过进程间通信（IPC）进行数据交换，如管道、消息队列、共享内存。
线程：通过共享内存直接通信，速度快但需注意同步。
并发性
进程：适合多任务并发，进程间隔离性好。
线程：适合多线程并发，资源共享效率高。

2、如何创建线程池？线程池常见参数有哪些？
创建线程池可通过Java的ThreadPoolExecutor构造函数或Executors工具类实现。
核心参数包括：核心线程数（维持常驻线程）、最大线程数（扩容上限）、存活时间（非核心线程空闲时长）、任务队列（存放待执行任务）、拒绝策略（队列满时的处理方式）。

3、请你说说HashMap底层原理和扩容机制。
在1.8之前，HashMap的底层是数组加链表，在1.8之后是数组+链表+红黑树； 
它的put流程是：基于哈希算法来确定元素位置，当我们向集合存入数据时，他会计算传入的key的哈希值，并利用哈希值取绝对值再根据集合长度取余来确定元素的位置，如果这个位置已经存在其他元素了，
就会发生哈希碰撞，则hashmap就会通过链表将这些元素组织起来，如果链表的长度达到8时，就会转化为红黑树，从而提高查询速度。 扩容机制：HashMap中数组的默认初始容量为16，当达到默认负载因子0.75时，
会以2的指数倍进行扩容。 Hashmap是非线程安全的，在多线程环境下回产生循环死链，因此在多线程环境下建议使用ConcurrentHashMap。

4、Redis如何与数据库保持双写一致性?

为确保Redis与数据库双写一致性，常用方法包括：先更新数据库再删缓存（Cache-Aside）、延迟双删（更新前后均删缓存并延迟二次删除）、
基于消息队列异步同步、监听数据库binlog触发缓存更新，以及设置缓存过期时间兜底。需结合业务场景选择策略，配合重试机制确保最终一致性。

5、说说JVM的垃圾回收算法。
1.引用计数法，每次赋值时均要维护引用计数器且计数器本身也有一定的消耗，较难处理循环引用，一般不采用这种方式； 
2.复制算法，将内存分为两块，每次只使用其中一块，当这块内存用完，就将还活着的对象复制到另外一块上面，效率高且没有碎片，但是需要双倍的空间，年轻代中使用复制算法； 
3.标记-清除，先标记要清除的对象，然后统一回收这些对象，不需要额外的空间，但是需要两次扫描耗时严重并且会产生内存碎片； 
4.标记-整理，标记存活对象，然后将标记的存活对象按内存地址依次排序，清除边界外未标记的对象，没有内存碎片，但是需要移动对象。老年代一般用标记-清除和标记-整理的混合实现。

6、详细的说说Redis的数据类型

Redis拥有五种基本数据类型和四种特殊的数据类型。 
五种基本数据类型 
1）String：String是Redis中最基本的数据类型，可以存储任何数据，包括二进制数据、序列化后的数据、JSON话的对象甚至是图片。 
2）List：list是字符串列表，按照插入的顺序排序，元素可以重复，你可以添加一个元素到列表的头部或者尾部，底层是一个链表结构。 
3）Set：set是一个无序不重复的集合。 
4）Hash：hash是String类型的filed和value的集合，适合用于存储对象。 
5）Zset：zset和set一样也是string类型元素的集合，且不允许重复的成员，但不同的是zset的每个元素都会关联一个分数，分数可以重复，Redis通过分数来为集合中的成员进行从小到大的排序。 
四种特殊的数据类型 
1）bitmap 
2）hyperloglog 
3）geo 
4）stream

7、请你说说ArrayList和LinkedList的区别。
ArrayList底层是数组实现的，数组是一组连续的内存单元，读取快（使用索引），插入删除慢（需要重新计算大小或是更新索引） 
LinkedList底层基于双向链表，读取慢，插入删除快；链表的每一个节点保存了数据值，和指向前一个节点的指针和指向后一个节点的指针。占内存

8、进程间通信方式有哪些？
进程间通信（IPC）方式包括管道、消息队列、共享内存、信号量、套接字（Socket）和信号等，每种方式在不同场景下具有独特的优势和适用性。

9、说说Redis的持久化策略。
redis的持久化策略有三种：
1.RDB持久化：将当前进程中的数据已生成快照的方式保存到硬盘中，是redis默认的持久化机制。优点：持久化时生成的文件体积小，恢复数据快，缺点：每次运行都需要执行fork操作，RDB持久化策略，没有做到实时的持久化，
有时可能会丢失最后一步的数据。
2.AOF持久化：以独立日志的方式记录每次写入的命令，重启时执行AOF中的命令即可恢复数据。优点：AOF持久化的安全性更高，保证了数据持久化的实时性。缺点：文件要大很多，恢复速度慢。
3.RDB-AOF持久化：这种方式是基于AOF持久化方式构建出来的。兼具RDB和AOF的优势。

重启 Redis：自动按以下优先级加载持久化文件：
仅 AOF 存在 → 加载 AOF。
仅 RDB 存在 → 加载 RDB。
AOF 和 RDB 均存在 → 加载 AOF（因其记录更完整）。

10、说说 TCP 的三次握手
第一次握手：客户端向服务器端发送SYN，确认客户端的发送没问题。
第二次握手：服务器向客户端发送SYN和ACK包，确认服务器的发送与接收没问题
第三次握手：客户端最后回复一个ACK包，确认客户端的接收没问题。

11、为什么 MySQL 采用 B+ 树作为索引？
1）B+Tree是多路自平衡的树结构，通常结构是矮胖结构，契合磁盘的I/O操作，可以大大减少数据查询时磁盘的I/O操作。
2）叶子节点中同时存储索引和数据，能避免数据查询的回表，较少磁盘的I/O次数。
3）叶子节点直接用链表结构进行连接，在范围查询时，可以直接在叶子节点进行顺序查询，而不需要重新从根节点查询。

12、SQL 调优常见方法有哪些？
1、合理使用索引：定期清理无用和重复的索引、 
2、优化查询语句：避免不必要的嵌套和复杂子查询 
3、尽量多使用过滤条件，减少全表扫描，限制返回的数据、避免一次性拉取大量数据 
4、开启并合理配置数据库的查询缓存功能

13、如何监控并优化慢 SQL？
监控并优化慢 SQL 可以通过启用慢查询日志、分析查询计划、优化索引和调整查询结构等方法实现。

14、事务隔离级别有哪些？
MySQL 提供四种事务隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read，MySQL 默认） 和 串行化（Serializable），
它们从低到高依次增强数据一致性，但并发性能递减。

15、讲一下乐观锁和悲观锁。
乐观锁假设操作冲突少，只在提交时检查数据是否被修改（如版本号机制），适用于读多写少场景。
悲观锁预先加锁（如行锁、表锁），确保独占操作，适合写多场景，但影响并发性能。前者减少锁竞争，后者保证强一致性。

16、如何利用Redis实现一个分布式锁？
方案一：SETNX + EXPIRE
方案二：SETNX + value值是（系统时间 + 过期时间）
方案三：使用Lua脚本（包含SETNX + EXPIRE两条指令）
方案四：SET的扩展命令（SET EX PX NX）
方案五：SET EX PX NX + 校验唯一随机值，再释放锁
方案六：开源框架：Redisson
方案七：多机实现的分布式锁Redlock

17、消息队列如何保证消息不丢？
消息队列通过多环节保障机制防止消息丢失：生产者使用确认机制（如ACK）确保消息成功发送至Broker；
Broker采用持久化存储（如磁盘写入）和副本同步防止数据丢失；消费者处理成功后手动提交确认，失败时触发重试；消息重试机制和死信队列处理异常情况；整体通过事务机制或幂等设计保证端到端一致性。

18、ConcurrentHashMap 线程安全的具体实现方式。
ConcurrentHashMap通过分段锁+CAS机制实现线程安全：
1.JDK7采用Segment分段锁，不同段可并发操作；
2.JDK8改为Node数组+链表/红黑树，使用synchronized锁单个桶节点；
3.volatile保证变量可见性；
4.CAS实现无锁化原子操作；
5.扩容时多线程协同迁移数据。

19、说说缓存穿透、击穿、雪崩的区别。
缓存穿透：客户端访问不存在的数据，使得请求直达存储层，导致负载过大，直至宕机。原因可能是业务层误删了缓存和库中的数据，或是有人恶意访问不存在的数据。
解决方式：1.存储层未命中后，返回空值存入缓存层，客户端再次访问时，缓存层直接返回空值。2.将数据存入布隆过滤器，访问缓存之前经过滤器拦截，若请求的数据不存在则直接返回空值。 

缓存击穿：一份热点数据，它的访问量非常大，在它缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。
解决方案：1.永不过期：对热点数据不设置过期时间。2.加互斥锁，当一个线程访问该数据时，另一个线程只能等待，这个线程访问之后，缓存中的数据将被重建，届时其他线程就可以从缓存中取值。 

缓存雪崩：大量数据同时过期、或是redis节点故障导致服务不可用，缓存层无法提供服务，所有的请求直达存储层，造成数据库宕机。
解决方案：1.避免数据同时过期，设置随机过期时间。2.启用降级和熔断措施。3.设置热点数据永不过期。4.采用redis集群，一个宕机，另外的还能用

20、TCP 协议如何保证可靠传输？
序列号 +超时重传 保证数据不漏不乱 
校验和 保证数据不损坏 
滑动窗口和流量控制 保证发送速率可控 
拥塞控制保证网络不被压垮

21、GET 与 POST 有什么区别?
拿数据 → GET	读操作，缓存友好
交数据 → POST	写操作，副作用
能刷新不变 → GET	幂等可重复
不可重试 → POST	避免重复写

22、说说线程的创建方式。
1. 继承Thread类并重写run方法。
2. 实现Runnable接口并实现run方法。
3. 使用Callable接口配合FutureTask实现带返回值的线程。
4. 通过线程池（如Executor框架）创建管理线程。
5. 使用Lambda表达式或匿名内部类简化线程实现

23、synchronized和Lock有什么区别？
1. 机制：synchronized是Java关键字，基于JVM实现自动锁管理；Lock是接口，需手动加锁解锁。
2. 灵活性：Lock支持非阻塞尝试锁（tryLock）、可中断锁、超时锁，synchronized无法实现。
3. 公平性：Lock可设置公平/非公平策略，synchronized仅支持非公平锁。
4. 条件变量：Lock可通过Condition绑定多个条件，synchronized仅一个等待队列。
5. 性能：高并发时Lock更高效，synchronized优化后差距缩小，但Lock需显式释放避免死锁。

24、说说什么是类加载机制
类加载机制是JVM动态加载类的过程，包含加载、验证、准备、解析和初始化五个阶段。加载阶段读取.class文件生成Class对象；验证确保字节码合法；
准备为静态变量分配内存并赋默认值；解析将符号引用转为直接引用；初始化执行静态代码块和变量赋值。各阶段顺序执行，确保类正确加载且符合安全规范。

25、Redis的Zset怎么实现？
Redis的Zset通过跳跃表和哈希表实现。哈希表存储成员到分数的映射以支持快速查询，跳跃表按分数排序成员以支持高效的范围操作。
两者结合确保插入、删除和查询的时间复杂度为O(log n)。数据量小时可能使用压缩列表优化内存。

26、消息队列如何保证不重复消费？
消息队列通过以下机制避免重复消费：
1. 生产者端添加唯一消息ID实现发送幂等性；
2. 消息队列服务端支持Exactly-Once语义（如Kafka事务消息）；
3. 消费者端采用去重机制（如数据库唯一索引、Redis原子操作记录已消费ID）；
4. 业务逻辑设计幂等处理（如状态检查、乐观锁）；
5. 正确维护消费位移，确保异常后能从正确位置恢复。

27、请你说一下抽象类和接口的区别
链接：https://www.nowcoder.com/questionTerminal/2734bb6f57fb42e787a3d09f5dd79391?examPageSource=25mianshitop
来源：牛客网

相同点：
1、两者都不能实例化；
2、可以拥有抽象方法。 
区别：
1、抽象类定义的关键字是abstract class，接口定义的关键字是interface；
2、属性上，抽象类可以有静态变量、常量和成员变量，接口只能有常量；
3、抽象方法可以有普通方法，而接口jdk1.8之前只能有抽像方法（1.8之后，增加了静态方法和默认方法）；
4、抽象方法可以有构造方法，接口不可以有构造方法。
5、一个类只能单继承一个父类，而一个接口可以继承多个父接口，同时，一个类可以实现多个接口却没有实现多个父类这一说法；
6、抽象方法在业务编程上更像一个模板，有自己的功能，同时也可以有优化补充的多种形式，而接口更像是一种规范和要求，实现就要按照要求来进行。

28、HTTP常见状态码
1xx / 101 请求继续 2xx / 200 响应成功 3xx / 302 302 重定向 4xx / 404 客户端错误，找不到地址 5xx 504 服务器错误 响应超时

























