1、什么是进程和线程？进程和线程的区别？  // 什么时候选用进程，什么时候选用线程？

线程是CPU调度的最小单位

进程是操作系统中资源分配的基本单位，线程是进程中执行的基本单位，进程拥有独立的内存空间，而线程共享进程的内存空间和资源。
进程拥有独立的内存空间，进程之间相互隔离，创建和切换的开销较大，通信需依赖进程间通信（如管道、消息队列、共享内存），适合多任务并发，隔离性和安全性较好。
而线程共享所属进程的内存空间，创建和切换开销小，通信可直接通过共享内存进行，速度更快但需注意同步问题，适合执行同一任务下的多线程并发，资源共享效率更高但隔离性较弱。

进程切换比线程切换更耗资源，因为它需要切换独立的内存空间和系统资源，而线程切换只需在同一进程内切换执行路径。

线程崩溃可能会导致进程崩溃，如果是内存非法访问导致的线程崩溃 由于线程间共享进程的虚拟地址和资源 操作系统会认为进程不安全 从而终止进程 导致进程崩溃
可以通过线程隔离 异常处理（捕获异常）等减少线程崩溃对进程的影响

2、如何创建线程池？线程池常见参数有哪些？
创建线程池可通过Java的ThreadPoolExecutor构造函数或Executors工具类实现。
核心参数包括：核心线程数（维持常驻线程）、最大线程数（扩容上限）、存活时间（非核心线程空闲时长）、任务队列（存放待执行任务）、拒绝策略（队列满时的处理方式）。

3、请你说说HashMap底层原理和扩容机制。
在1.8之前，HashMap的底层是数组加链表，在1.8之后是数组+链表+红黑树； 

它的put流程是：基于哈希算法来确定元素位置，当我们向集合存入数据时，他会计算传入的key的哈希值，然后使用扰动函数处理，再根据数组长度取模来确定元素的位置，如果这个位置已经存在其他元素了，
就会发生哈希冲突，则hashmap就会通过链表将这些元素组织起来，如果链表的长度达到8且数组长度大于等于64时，就会转化为红黑树，从而提高查询速度。

扩容机制：HashMap中数组的默认初始容量为16，当达到默认负载因子0.75时，会以2的指数倍进行扩容。 Hashmap是非线程安全的，在多线程环境下回产生循环死链，因此在多线程环境下建议使用ConcurrentHashMap。
只有当链表长度大于等于8且数组长度大于等于64时，链表才会转换为红黑树（否则只是扩容）

4、Redis如何与数据库保持双写一致性?

为确保Redis与数据库双写一致性，常用方法包括：先更新数据库再删缓存（Cache-Aside）、延迟双删（更新前后均删缓存并延迟二次删除）、
基于消息队列异步同步、监听数据库binlog触发缓存更新，以及设置缓存过期时间兜底。需结合业务场景选择策略，配合重试机制确保最终一致性。

5、说说JVM的垃圾回收算法。
1.引用计数法，每次赋值时均要维护引用计数器且计数器本身也有一定的消耗，较难处理循环引用，一般不采用这种方式； 
2.复制算法，将内存分为两块，每次只使用其中一块，当这块内存用完，就将还活着的对象复制到另外一块上面，效率高且没有碎片，但是需要双倍的空间，年轻代中使用复制算法； 
3.标记-清除，先标记要清除的对象，然后统一回收这些对象，不需要额外的空间，但是需要两次扫描耗时严重并且会产生内存碎片； 
4.标记-整理，标记存活对象，然后将标记的存活对象按内存地址依次排序，清除边界外未标记的对象，没有内存碎片，但是需要移动对象。老年代一般用标记-清除和标记-整理的混合实现。

6、详细的说说Redis的数据类型
Redis拥有五种基本数据类型和四种特殊的数据类型。 
五种基本数据类型 
1）String：String是Redis中最基本的数据类型，可以存储任何数据，包括二进制数据、序列化后的数据、JSON话的对象甚至是图片。 
2）List：list是字符串列表，按照插入的顺序排序，元素可以重复，你可以添加一个元素到列表的头部或者尾部，底层是一个链表结构。 
3）Set：set是一个无序不重复的集合。 
4）Hash：hash是String类型的filed和value的集合，适合用于存储对象。 
5）Zset：zset和set一样也是string类型元素的集合，且不允许重复的成员，但不同的是zset的每个元素都会关联一个分数，分数可以重复，Redis通过分数来为集合中的成员进行从小到大的排序。 
四种特殊的数据类型 
1）bitmap 
2）hyperloglog 
3）geo 
4）stream

7、请你说说ArrayList和LinkedList的区别。
ArrayList底层是数组实现的，数组是一组连续的内存单元，读取快（使用索引），插入删除慢（需要重新计算大小或是更新索引） 
LinkedList底层基于双向链表，读取慢，插入删除快；链表的每一个节点保存了数据值，和指向前一个节点的指针和指向后一个节点的指针。占内存

8、进程间通信方式有哪些？
进程间通信（IPC）方式包括管道、消息队列、共享内存、信号量、套接字（Socket）和信号等，每种方式在不同场景下具有独特的优势和适用性。

9、说说Redis的持久化策略。
redis的持久化策略有三种：
1.RDB持久化：将当前进程中的数据已生成快照的方式保存到硬盘中，是redis默认的持久化机制。优点：持久化时生成的文件体积小，恢复数据快，缺点：每次运行都需要执行fork操作，RDB持久化策略，没有做到实时的持久化，
有时可能会丢失最后一步的数据。
2.AOF持久化：以独立日志的方式记录每次写入的命令，重启时执行AOF中的命令即可恢复数据。优点：AOF持久化的安全性更高，保证了数据持久化的实时性。缺点：文件要大很多，恢复速度慢。
3.RDB-AOF持久化：这种方式是基于AOF持久化方式构建出来的。兼具RDB和AOF的优势。

重启 Redis：自动按以下优先级加载持久化文件：
仅 AOF 存在 → 加载 AOF。
仅 RDB 存在 → 加载 RDB。
AOF 和 RDB 均存在 → 加载 AOF（因其记录更完整）。

10、说说 TCP 的三次握手
第一次握手：客户端向服务器端发送SYN，确认客户端的发送没问题。
第二次握手：服务器向客户端发送SYN和ACK包，确认服务器的发送与接收没问题
第三次握手：客户端最后回复一个ACK包，确认客户端的接收没问题。

11、为什么 MySQL 采用 B+ 树作为索引？
1）B+Tree是多路自平衡的树结构，通常结构是矮胖结构，契合磁盘的I/O操作，可以大大减少数据查询时磁盘的I/O操作。
2）叶子节点中同时存储索引和数据，能避免数据查询的回表，较少磁盘的I/O次数。
3）叶子节点直接用链表结构进行连接，在范围查询时，可以直接在叶子节点进行顺序查询，而不需要重新从根节点查询。

12、SQL 调优常见方法有哪些？
1、合理使用索引：定期清理无用和重复的索引、 
2、优化查询语句：避免不必要的嵌套和复杂子查询 
3、尽量多使用过滤条件，减少全表扫描，限制返回的数据、避免一次性拉取大量数据 
4、开启并合理配置数据库的查询缓存功能

13、如何监控并优化慢 SQL？
监控并优化慢 SQL 可以通过启用慢查询日志、分析查询计划、优化索引和调整查询结构等方法实现。

14、事务隔离级别有哪些？
MySQL 提供四种事务隔离级别：读未提交（Read Uncommitted）、读已提交（Read Committed）、可重复读（Repeatable Read，MySQL 默认） 和 串行化（Serializable），
它们从低到高依次增强数据一致性，但并发性能递减。

15、讲一下乐观锁和悲观锁。
乐观锁假设操作冲突少，只在提交时检查数据是否被修改（如版本号机制），适用于读多写少场景。
悲观锁预先加锁（如行锁、表锁），确保独占操作，适合写多场景，但影响并发性能。前者减少锁竞争，后者保证强一致性。

16、如何利用Redis实现一个分布式锁？
方案一：SETNX + EXPIRE
方案二：SETNX + value值是（系统时间 + 过期时间）
方案三：使用Lua脚本（包含SETNX + EXPIRE两条指令）
方案四：SET的扩展命令（SET EX PX NX）
方案五：SET EX PX NX + 校验唯一随机值，再释放锁
方案六：开源框架：Redisson
方案七：多机实现的分布式锁Redlock

17、消息队列如何保证消息不丢？
消息队列通过多环节保障机制防止消息丢失：生产者使用确认机制（如ACK）确保消息成功发送至Broker；
Broker采用持久化存储（如磁盘写入）和副本同步防止数据丢失；消费者处理成功后手动提交确认，失败时触发重试；消息重试机制和死信队列处理异常情况；整体通过事务机制或幂等设计保证端到端一致性。

18、ConcurrentHashMap 线程安全的具体实现方式。
ConcurrentHashMap通过分段锁+CAS机制实现线程安全：
1.JDK7采用Segment分段锁，不同段可并发操作；
2.JDK8改为Node数组+链表/红黑树，使用synchronized锁单个桶节点；
3.volatile保证变量可见性；
4.CAS实现无锁化原子操作；
5.扩容时多线程协同迁移数据。

讲一下Java里的CAS。
1.CAS即compare and swap，比较并交换，比较典型的场景有原子类，AQS和并发容器等等。 
2.当应用场景为原子类时，比如java.util.concurrent.atomic.AtomicInteger包内部，有很多原子操作的方法比如增加指定的值，自动加1等等，他们的底层都是操作系统通过CAS实现的 
3.当应用场景为AQS时，AQS在向队列尾部添加节点的时候，它首先会以CAS的方式尝试一次，如果失败，则进入自旋状态，接着反复使用CAS方法。
4.当应用场景为并发容器，比如ConcurrentHashMap,在进行数组初始化的时候，用到了CAS，防止多个线程同时进行初始化，在进行数组扩容的时候，也用到了CAS，让多个线程同时竞争扩容任务，防止和其他线程产生冲突

AQS（AbstractQueuedSynchronizer）是Java并发包的核心同步框架，通过内置的FIFO队列管理线程竞争，使用volatile变量state表示同步状态。它提供独占和共享两种模式，
子类只需重写tryAcquire/tryRelease等模板方法即可实现锁、信号量等同步器（如ReentrantLock/Semaphore），解决了同步控制中线程排队与唤醒的底层细节问题。

CAS是乐观锁。因为其无阻塞和冲突检测，仅在提交的时候检查数据是否被修改，符合乐观锁先操作后冲突处理的逻辑

19、说说缓存穿透、击穿、雪崩的区别。
缓存穿透：客户端访问不存在的数据，使得请求直达存储层，导致负载过大，直至宕机。原因可能是业务层误删了缓存和库中的数据，或是有人恶意访问不存在的数据。
解决方式：1.存储层未命中后，返回空值存入缓存层，客户端再次访问时，缓存层直接返回空值。2.将数据存入布隆过滤器，访问缓存之前经过滤器拦截，若请求的数据不存在则直接返回空值。 

缓存击穿：一份热点数据，它的访问量非常大，在它缓存失效的瞬间，大量请求直达存储层，导致服务崩溃。
解决方案：1.永不过期：对热点数据不设置过期时间。2.加互斥锁，当一个线程访问该数据时，另一个线程只能等待，这个线程访问之后，缓存中的数据将被重建，届时其他线程就可以从缓存中取值。 

缓存雪崩：大量数据同时过期、或是redis节点故障导致服务不可用，缓存层无法提供服务，所有的请求直达存储层，造成数据库宕机。
解决方案：1.避免数据同时过期，设置随机过期时间。2.启用降级和熔断措施。3.设置热点数据永不过期。4.采用redis集群，一个宕机，另外的还能用

20、TCP 协议如何保证可靠传输？
序列号 +超时重传 保证数据不漏不乱 
校验和 保证数据不损坏 
滑动窗口和流量控制 保证发送速率可控 
拥塞控制保证网络不被压垮

21、GET 与 POST 有什么区别?
拿数据 → GET	读操作，缓存友好
交数据 → POST	写操作，副作用
能刷新不变 → GET	幂等可重复
不可重试 → POST	避免重复写

22、说说线程的创建方式。
1. 继承Thread类并重写run方法。
2. 实现Runnable接口并实现run方法。
3. 使用Callable接口配合FutureTask实现带返回值的线程。
4. 通过线程池（如Executor框架）创建管理线程。
5. 使用Lambda表达式或匿名内部类简化线程实现

23、synchronized和Lock有什么区别？
1. 机制：synchronized是Java关键字，基于JVM实现自动锁管理；Lock是接口，需手动加锁解锁。
2. 灵活性：Lock支持非阻塞尝试锁（tryLock）、可中断锁、超时锁，synchronized无法实现。
3. 公平性：Lock可设置公平/非公平策略，synchronized仅支持非公平锁。
4. 条件变量：Lock可通过Condition绑定多个条件，synchronized仅一个等待队列。
5. 性能：高并发时Lock更高效，synchronized优化后差距缩小，但Lock需显式释放避免死锁。

24、说说什么是类加载机制
类加载机制是JVM动态加载类的过程，包含加载、验证、准备、解析和初始化五个阶段。加载阶段读取.class文件生成Class对象；验证确保字节码合法；
准备为静态变量分配内存并赋默认值；解析将符号引用转为直接引用；初始化执行静态代码块和变量赋值。各阶段顺序执行，确保类正确加载且符合安全规范。

25、Redis的Zset怎么实现？
Redis的Zset通过跳跃表和哈希表实现。哈希表存储成员到分数的映射以支持快速查询，跳跃表按分数排序成员以支持高效的范围操作。
两者结合确保插入、删除和查询的时间复杂度为O(log n)。数据量小时可能使用压缩列表优化内存。

26、消息队列如何保证不重复消费？
消息队列通过以下机制避免重复消费：
1. 生产者端添加唯一消息ID实现发送幂等性；
2. 消息队列服务端支持Exactly-Once语义（如Kafka事务消息）；
3. 消费者端采用去重机制（如数据库唯一索引、Redis原子操作记录已消费ID）；
4. 业务逻辑设计幂等处理（如状态检查、乐观锁）；
5. 正确维护消费位移，确保异常后能从正确位置恢复。

27、请你说一下抽象类和接口的区别
相同点：
1、两者都不能实例化；
2、可以拥有抽象方法。 
区别：
1、抽象类定义的关键字是abstract class，接口定义的关键字是interface；
2、属性上，抽象类可以有静态变量、常量和成员变量，接口只能有常量；
3、抽象方法可以有普通方法，而接口jdk1.8之前只能有抽像方法（1.8之后，增加了静态方法和默认方法）；
4、抽象方法可以有构造方法，接口不可以有构造方法。
5、一个类只能单继承一个父类，而一个接口可以继承多个父接口，同时，一个类可以实现多个接口却没有实现多个父类这一说法；
6、抽象方法在业务编程上更像一个模板，有自己的功能，同时也可以有优化补充的多种形式，而接口更像是一种规范和要求，实现就要按照要求来进行。

28、HTTP常见状态码
1xx / 101 请求继续 2xx / 200 响应成功 3xx / 302 302 重定向 4xx / 404 客户端错误，找不到地址 5xx 504 服务器错误 响应超时

29、说说volatile的用法及原理。
1.修饰被不同线程访问和修改的变量 
2.被其修饰的变量，系统每次用到它时都是直接从对应的内存中提取，而不会利用缓存（如寄存器），所有线程在任何时候所看到变量的值都是相同的 
3.volatile不能保证操作的原子性，因此不能代替synchronized ，只能保证可见性和有序性。对于多线程环境下的复合操作（如i++），即使变量被声明为volatile，仍需通过加锁或使用原子类来确保原子性操作。
4.能不使用就尽量不要使用

其原理是通过内存屏障（Memory Barrier）实现：写操作后插入StoreStore和StoreLoad屏障，读操作前插入LoadLoad和LoadStore屏障，确保修改可见性与指令执行顺序符合预期。但无法保证复合操作的原子性。

30、分布式锁的原理和常见的实现有哪些？
分布式锁通过在共享存储系统中维护互斥状态，确保多个节点间资源访问的排他性。常见实现包括：
1. 基于数据库（如唯一约束、乐观锁）；
2. Redis（SETNX命令或RedLock算法）；
3. ZooKeeper（临时有序节点+Watcher监听）；
4. Etcd（基于Raft协议的事务与租约机制）。不同方案在性能、一致性和复杂度上各有取舍。

31、设计一个支持万人同时抢购商品的秒杀系统，如何解决超卖、库存扣减和高并发请求问题？
一、核心挑战分析
超卖问题：多线程并发扣减库存导致库存负数。
库存准确性：分布式环境下如何保证扣减原子性。
高并发流量：瞬时流量可达数十万QPS，需避免服务雪崩。
数据一致性：订单、库存、支付状态的最终一致性保障。

二、流量削峰与限流策略
CDN 与边缘缓存：
静态资源（如商品图片、活动页）预先缓存至 CDN，减少回源压力。
前端限流：
添加滑块验证码、答题验证等手段防止机器人刷单。
客户端侧加随机延迟与按钮置灰，避免重复点击。
网关层限流与排队机制：
利用 Nginx + Lua 实现令牌桶限流控制（如 1 万 QPS）。
请求进入排队系统，返回排队进度提示，模拟 12306 购票方式。

三、防超卖与库存预扣机制
Redis 预扣库存：
使用 Redis 的 DECR 或 Lua 脚本实现原子扣减，避免并发冲突。
库存分桶技术：
将总库存拆分成多个“库存桶”，每个桶独立处理，降低热点竞争。
例如：1000 件商品可划分成 10 个桶，每个 100 件。
异步落库与补偿机制：
扣减 Redis 库存后，通过消息队列异步通知数据库处理。
若数据库更新失败，可通过 MQ 实现库存补偿，防止数据丢失。

四、高并发订单处理方案
异步下单机制：
用户抢购成功后生成唯一令牌（Token），跳转到下单页面。
用户提交 Token 后将请求推入消息队列异步处理。
消息队列优化：
按用户 ID 进行分区，确保单个用户请求顺序性。
支持批量消费（如一次处理 100 条订单），提高吞吐率。
订单去重策略：
使用 Redis Set 存储已处理 Token，防止用户重复提交订单。

五、缓存与数据库协同优化
多级缓存架构：
本地缓存（如 Caffeine）缓存商品基础信息（非库存），减少 Redis 压力。
Redis 采用集群模式（如 Codis 或 Redis Cluster）进行分片存储。
数据库层优化：
实现分库分表策略，订单表按用户 ID 分片，库存表按商品 ID 分片。
库存扣减语句使用乐观锁机制：

六、系统降级与容灾机制
服务熔断与降级：
实时监控数据库或 Redis 负载，超过阈值自动熔断非核心模块（如积分功能）。
商品秒杀结束或异常时，返回静态售罄页，跳过后端逻辑处理。
数据核对与修复：
定期比对 Redis 与数据库的库存数据，自动修复不一致情况，保障数据准确。


32、说一下Java中的深拷贝、浅拷贝、引用拷贝。
1.引用拷贝：不创建新对象，复制引用地址，多个变量指向同一个对象。例如：Zoo zoo1 = new Zoo();Zoo zoo2 = zoo1;此时zoo1和zoo2指向同一个对象
2.浅拷贝：创建新对象，调用clone()方法，复制对象的基本类型字段的值，复制对象的引用类型字段的地址，也就是说对象的引用类型字段还是指向同一个对象
3.深拷贝：创建新对象，实现Cloneable接口，重写clone()方法递归复制对象的所有引用字段，新对象与旧对象完全独立，包括引用类型字段

33、ThreadLocal 的用法和实现原理。
ThreadLocal 是用于保存线程局部变量的工具类，为每个线程提供一份独立副本，实现线程间的数据隔离。

实现原理：
每个线程维护一个 ThreadLocalMap，当调用 threadLocal.set(value) 时，实际是把数据存入当前线程的 ThreadLocalMap 中；key 是当前的 ThreadLocal 对象，value 是设置的值。
每个线程有自己独立的 ThreadLocalMap；即使多个线程使用同一个 ThreadLocal 对象，它们互相之间无法访问彼此的值
ThreadLocalMap 的 key 是弱引用，value 是线程对应的数据，如果 ThreadLocal 对象被 GC 回收而未手动调用 remove()，就可能造成 value 无法被回收（强引用还存在），导致内存泄漏。

当你在使用线程池时，线程是复用的，不是执行完任务就销毁，而是长期驻留在线程池中。这就带来了一个问题：
ThreadLocal 绑定的数据对象也会跟随线程长期存活，如果不手动清理，就可能导致这些对象无法被 GC 回收，从而形成 内存泄漏。

解决办法：在使用线程池时，ThreadLocal 用完必须 remove，否则其 value 随线程长期存活，无法被 GC 回收，容易造成内存泄漏。

34、什么情况下会出现死锁？如何避免死锁？
当多个线程因相互持有并等待对方释放资源，且形成环路时会发生死锁；
避免死锁可通过破坏必要条件（如统一锁顺序、尝试锁、超时锁、锁级别、锁析构顺序）或使用死锁检测/避免算法。

35、布隆过滤器的原理。
布隆过滤器通过多个哈希函数将元素映射到位数组中，置位对应位置。查询时若所有哈希位均为1则可能存在，否则必定不存在。
其优点是空间效率高，但存在一定误判率且无法删除元素，适用于允许误差的快速存在性检测场景。

36、String、StringBuffer、Stringbuilder有什么区别？
StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且方法也一样
String:不可变字符序列，效率低，但是复用率高。
StringBuffer:可变字符序列、效率较高(增删)、线程安全
StringBuilder:可变字符序列、效率最高、线程不安全

37、说说你对AOP的理解。
AOP是面向切面编程，它是一种编程思想，它是一种通过预编译方式和运行期间动态代理的方式实现不修改源代码的情况下给程序动态添加功能的一种技术，可以降低代码的耦合度，便于管理，提高代码的可重用性。 
AOP的实现方式有两种： JDK动态代理，可以在运行时创建接口的代理实例。 CGLIB动态代理：可以在运行期间创建子类的动态实例。 AOP的应用场景有：事务，日志管理等。

38、MySQL 中的 MVCC 是什么？Read View 在 MVCC 中如何工作？如果没有 MVCC 会怎样？
MVCC是多版本并发控制的简称，用来实现事务除串行化之外的隔离级别，如可重复读快照读可以解决幻读，ReadView是一个类，用来控制当前事务对其他事务的可见性，如果没有MVCC，事务隔离级别将难以实现

39、redo log / undo log / binlog 各自作用？
redo log用于数据恢复，undo log用于事务回滚，binlog用于数据复制和恢复，三者在 MySQL 中各司其职，确保数据一致性和持久性。

40、说说synchronize的用法及原理
synchronized 是 Java 中用于线程同步的关键字，它通过对代码块或方法加锁，来保证在多线程环境下共享资源的互斥访问，避免线程安全问题。

synchronized可以修饰静态方法、普通方法、代码块。 能够保证同一个时刻只有一个线程执行该段代码，保证线程安全。 
在执行完或者出现异常时自动释放锁。 synchronized作用在代码块时，它的底层是通过monitorenter、monitorexit指令来实现的。

41、I/O 多路复用（select/poll/epoll）是什么？通常适用哪些场景？
I/O 多路复用（select/poll/epoll）是一种高效管理多个 I/O 事件的机制，允许单个线程同时监控多个文件描述符的状态变化，适用于高并发网络服务器和需要处理大量 I/O 连接的场景。

42、线程间同步方式有哪些？
线程间同步方式包括互斥锁、读写锁、条件变量、信号量和自旋锁等，每种方式在不同场景下提供了对共享资源的有效控制。
在多线程编程中，线程间同步是确保多个线程安全访问共享资源的关键。不同的同步机制适用于不同的应用场景，理解这些机制有助于编写高效且安全的多线程程序。

43、什么是 LRU 算法？
LRU（Least Recently Used）算法是一种缓存/页面置换策略：始终优先淘汰“最后一次被访问时间最久远”的那一项，用时间局部性原则来最大化命中率。

44、多线程冲突了怎么办？  //  介绍一下你知道的锁
多线程冲突可以通过使用同步机制如互斥锁、读写锁、条件变量等来解决，以确保线程安全地访问共享资源。

互斥锁（Mutex）
提供对共享资源的独占访问，防止并发修改。使用时加锁、解锁，适合需要线程互斥的场景。

读写锁（Read-Write Lock）
允许多线程并发读，但写操作需独占。适合读多写少的情况。

条件变量（Condition Variable）
实现线程间条件等待，线程阻塞直到条件满足。适用于依赖状态变化的场景。
📌 类比：红绿灯，车等绿灯才能走。

信号量（Semaphore）
用于限制并发访问数量，通过计数控制资源访问。适合控制并发量的资源分配。
📌 类比：停车场，车位满了要等待。

自旋锁（Spinlock）
线程在获取锁时不断尝试而不阻塞，适合锁持有时间很短的场景。
📌 类比：不停试门把手，看门是否开了。

45、什么情况下会发生死锁？
死锁发生在多个进程或线程因相互等待对方释放资源而无法继续执行的情况下，通常需要满足互斥、持有并等待、不剥夺和循环等待四个条件

46、如何解决 / 解除死锁？
解决或解除死锁可以通过预防、避免、检测和恢复等策略，具体方法包括资源分配顺序、银行家算法、超时机制、强制释放资源和进程优先级调整等。理解和应用这些方法有助于设计稳定高效的并发系统。

检测死锁：使用jstack分析线程转储或通过ThreadMXBean的findDeadlockedThreads方法。
预防死锁：1.按固定顺序获取锁，破坏循环等待；2.避免嵌套锁；3.使用tryLock设置超时机制；4.减少同步代码块范围。

47、同步与异步的区别？
同步与异步的区别在于任务的执行方式和等待机制：同步任务需要等待前一个任务完成后才能继续，而异步任务可以在等待期间执行其他任务，从而提高系统的并发性和响应速度。

48、内存泄漏与内存溢出分别指什么？
内存泄漏是"借了空间却忘了还"导致存量内存被慢慢占死，
而内存溢出则是"一下子把仓库塞爆"导致申请瞬间失败或系统直接崩溃，它们关注的都是内存，但本质、成因与表现完全不同。

49、说说wait()和sleep()的区别。
Thread.sleep() 是 Thread 的静态方法，用于让当前线程休眠指定时间，不会释放已有锁，也不依赖其他线程恢复。
Object.wait() 是实例方法，必须在同步代码块中调用，调用后线程会释放锁并进入等待状态，需其他线程调用同一对象的 notify() 或 notifyAll() 来唤醒。
两者都会让线程暂停执行，但 wait() 适用于线程通信，sleep() 更适合用于简单的延时等待。两者暂停期间都不占用 CPU，核心区别在于是否释放锁和是否依赖其他线程唤醒。

50、synchronization和volatile有什么区别：
1.synchronization是同步锁，可以保证数据可见性和原子性；volatile不是锁而是关键字，只能保证数据可见性，不能保证原子性
2.synchronization可以修饰方法、代码块，volatile只能修饰变量
3.volatile可以禁止指令重排，synchronization不能禁止指令重排

51、说说你了解的线程同步的方式

java主要通过加锁的方式实现线程同步：主要有两种方式：synchronized关键字和lock接口。
synchronized可以加在三个不同的位置，对应着三种不同范围，区别是锁对象的不同：
1.加在实例方法上，锁的就是当前的实例。
2.加在静态方法和类上，锁的就是当前整个类。
3.加在代码块上，锁的就是代码块里面的内容。我们应该合理的选择锁的对象。lock锁接口除了支持上述功能外，还支持了响应中断，超时机制，阻塞队列等。

52、公平锁与非公平锁有什么区别？
1.非公平锁，不考虑线程请求锁的顺序，谁有能力谁获取锁，性能较好，减少线程上下文切换
2.公平锁，考虑线程请求锁的顺序，讲究一个先到先得，性能较差，线程上下文切换比较多

53、CAS会出现什么问题？ABA如何解决？
CAS操作包含三个参数，内存位置，预期旧值，新值，用于在并发中保证数据一致性和线程安全，操作逻辑是如果内存位置等于预期旧值，就把新值更新进去。会出现ABA问题
ABA问题是在CAS过程中，并发中，从A变回B，又变回A，CAS错误认为变量没有变化。 解决ABA问题 1.使用版本号，在变量值之外再维护一个版本号或时间戳

54、介绍下ReentrantLock的定义和特性。
ReentrantLock的理解
ReentrantLock是Java中基于接口实现的可重入互斥锁，需要手动加锁释放锁，提供线程同步功能。支持公平/非公平模式，允许线程重复获取锁且不会死锁。特性包括可中断锁获取、超时尝试锁及绑定多个Condition条件变量。
相比synchronized更灵活控制并发，适用于复杂多线程场景。


ReentrantReadWriteLock的使用场景是？
ReentrantReadWriteLock（可重入读写锁）适用于读多写少的高并发场景，如缓存系统。读操作共享资源时可允许多线程并行访问，提升性能；写操作独占资源保证数据一致性
通过分离读写锁降低线程竞争，适合需要频繁读取但较少修改的数据同步需求。

55、线程池常用的阻塞队列有哪些？
线程池常用的阻塞队列包括：
1. ArrayBlockingQueue（基于数组的有界队列）；
2. LinkedBlockingQueue（基于链表的可选有界/无界队列）；
3. SynchronousQueue（不存储元素，直接传递任务）；
4. PriorityBlockingQueue（支持优先级排序的无界队列）。
此外，ScheduledThreadPoolExecutor使用延迟队列DelayedWorkQueue处理定时任务。

56、说一下：Callable 和 Future。
Callable是Java中可返回结果和抛出异常的任务接口，常用于多线程异步执行。
Future代表异步计算结果，提供检查任务状态、获取结果或取消任务的方法。
两者配合使用时，Callable定义具体任务逻辑，Future用于监控和获取任务执行结果。通过线程池提交Callable任务会返回Future对象，实现异步处理机制。主要解决传统Runnable接口无法获取返回值的局限性。

57、Java线程和操作系统线程有什么区别

Java线程是JVM层面的抽象，现代主流实现（如HotSpot）采用1:1模型直接映射操作系统内核线程。 
区别在于：1.抽象层次不同（JVM管理状态/优先级，操作系统实际调度）； 2.部分特性不完全对应（如中断机制）； 3.JVM可能优化线程创建/销毁过程。最终执行仍依赖操作系统线程。 4.JVM提供跨平台一致性。

58、JDK动态代理是什么？和cglib区别？

JDK动态代理是Java基于接口实现的代理技术，通过反射机制在运行时生成代理类。
与CGLib的区别：1. JDK需实现接口，CGLib通过继承直接代理普通类；2. JDK无需第三方库，CGLib需引入ASM包；3. CGLib无法代理final类/方法，JDK无法代理无接口类；4. CGLib生成代理类性能通常更高。

59、请说说你对反射的了解。
反射就是在程序运行期间动态的获取对象的属性和方法的功能叫做反射。它能够在程序运行期间，对于任意一个类，都能知道它所有的方法和属性，对于任意一个对象，都能知道他的属性和方法。
获取Class对象的三种方式：getClass();xx.class;Class.forName("xxx"); 
反射的优缺点： 优点：运行期间能够动态的获取类，提高代码的灵活性。 缺点：性能比直接的Java代码要慢很多。 应用场景：spring的xml配置模式，以及动态代理模式都用到了反射。

60、你知道哪些线程安全的集合？举例你是怎么使用的？
常见线程安全的集合包括ConcurrentHashMap、CopyOnWriteArrayList和BlockingQueue系列。例如在多线程统计时使用ConcurrentHashMap的compute方法保证原子计数，用CopyOnWriteArrayList维护监听器列表避免遍历时加锁，
通过LinkedBlockingQueue实现生产者-消费者任务队列。Java并发包中的集合通过分段锁或写时复制机制实现高效线程安全。

hashTable/vector/concurrentHasmap是线程安全的。 另外Collections工具类提供了相应的方法，可以将不安全的集合类包装成安全的集合类。

61、介绍下Java中的static关键字。静态方法能不能调用非静态成员?
static关键字用于修饰类级别的成员，独立于实例存在。静态方法不能直接调用非静态成员（变量/方法），因为非静态成员依赖对象实例，而静态方法在类加载时即可调用，此时实例可能不存在。
需通过对象实例间接访问非静态成员

62、请你说一下final关键字。
final可以修饰类，方法，变量。 final修饰类，该类不可被继承。 final修饰方法，该方法不能被重写。 final修饰变量，如果是基本变量则值不能再改变，如果是引用变量则引用地址不能改变，但值可以改变。

63、介绍一下基本类型和包装类型的区别？
基本数据类型：直接存储数据值，占用固定内存，默认值不为null；适合高频计算场景，不需要对象开销 
包装类型：是对象，默认值为null，存储在堆内存中，支持泛型和方法调用；适合需要适用对象的场景，如泛型，数据库映射，反射获取属性等

64、介绍一下Java的泛型。
Java泛型是一种类型参数化机制，允许在类、接口和方法中定义类型占位符（如<T>）。它通过编译时类型检查确保数据安全，避免了运行时的强制类型转换和ClassCastException。
泛型提高了代码重用性，支持集合框架的类型安全操作，并通过类型擦除机制实现向后兼容。

65、介绍一下Java基本数据类型和引用类型。
Java基本数据类型包括8种：byte、short、int、long（整型），float、double（浮点型），char（字符型），boolean（布尔型），直接存储数值于栈内存。
引用类型（如类、数组、接口）存储对象内存地址，实际对象存储在堆内存，默认值为null。两者核心区别在于存储方式和内存分配机制。

66、Java的Object类有哪些方法？
Java的Object类包含以下方法：
getClass(), hashCode(), equals(), toString(), clone(),
finalize(), notify(), notifyAll(), wait()（含三个重载版本）。

67、什么是序列化?什么是反序列化?
序列化是将对象转换为可存储或传输的格式（如字节流、JSON），便于保存或网络传输。
反序列化是逆向过程，将序列化后的数据恢复为原始对象结构，实现数据的重构和使用。两者常用于数据持久化、缓存或跨平台通信场景。

常见序列化协议包括JSON（轻量级文本格式）、XML（可扩展标记语言）、Protocol Buffers（高效二进制协议）、MessagePack（紧凑二进制格式）、Apache Avro（支持动态模式）。其他如Thrift、BSON等也广泛应用。

68、介绍一下包装类的自动拆箱与自动装箱。
自动装箱是基本数据类型自动转换为对应的包装类对象（如int→Integer），
自动拆箱则是包装类对象转为基本类型（如Integer→int）。该机制由编译器在编译阶段实现，简化代码书写，例如集合存储基本类型时会自动装箱。需注意频繁拆装箱可能影响性能，且拆箱时若对象为null会抛出空指针异常。

69、什么是 BlockingQueue？都有哪些实现？
BlockingQueue是JUC包下面的线程安全队列接口，常见的实现有ArrayBlockingQueue（固定大小）、LinkedBlockingQueue（无界）、PriorityBlockingQueue（无界、有优先级），常用于实现生产者—消费者模型，
使用ReentrantLock保证线程安全，有两个条件变量，队列为空的时候阻塞消费者线程，队列满的时候阻塞生产者线程。经常应用于线程池的缓存队列





































































